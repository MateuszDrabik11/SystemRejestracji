// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: com.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_com_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_com_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_com_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_com_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_com_2eproto;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class account_message;
struct account_messageDefaultTypeInternal;
extern account_messageDefaultTypeInternal _account_message_default_instance_;
class account_request;
struct account_requestDefaultTypeInternal;
extern account_requestDefaultTypeInternal _account_request_default_instance_;
class add_account_msg;
struct add_account_msgDefaultTypeInternal;
extern add_account_msgDefaultTypeInternal _add_account_msg_default_instance_;
class ekg_res_message;
struct ekg_res_messageDefaultTypeInternal;
extern ekg_res_messageDefaultTypeInternal _ekg_res_message_default_instance_;
class event_response;
struct event_responseDefaultTypeInternal;
extern event_responseDefaultTypeInternal _event_response_default_instance_;
class exam_message;
struct exam_messageDefaultTypeInternal;
extern exam_messageDefaultTypeInternal _exam_message_default_instance_;
class med_event_message;
struct med_event_messageDefaultTypeInternal;
extern med_event_messageDefaultTypeInternal _med_event_message_default_instance_;
class mor_res_message;
struct mor_res_messageDefaultTypeInternal;
extern mor_res_messageDefaultTypeInternal _mor_res_message_default_instance_;
class mri_res_message;
struct mri_res_messageDefaultTypeInternal;
extern mri_res_messageDefaultTypeInternal _mri_res_message_default_instance_;
class patient_message;
struct patient_messageDefaultTypeInternal;
extern patient_messageDefaultTypeInternal _patient_message_default_instance_;
class prescribtion_message;
struct prescribtion_messageDefaultTypeInternal;
extern prescribtion_messageDefaultTypeInternal _prescribtion_message_default_instance_;
class procedure_message;
struct procedure_messageDefaultTypeInternal;
extern procedure_messageDefaultTypeInternal _procedure_message_default_instance_;
class result;
struct resultDefaultTypeInternal;
extern resultDefaultTypeInternal _result_default_instance_;
class rtg_res_message;
struct rtg_res_messageDefaultTypeInternal;
extern rtg_res_messageDefaultTypeInternal _rtg_res_message_default_instance_;
class schedule_message;
struct schedule_messageDefaultTypeInternal;
extern schedule_messageDefaultTypeInternal _schedule_message_default_instance_;
class schedule_request;
struct schedule_requestDefaultTypeInternal;
extern schedule_requestDefaultTypeInternal _schedule_request_default_instance_;
class usg_res_message;
struct usg_res_messageDefaultTypeInternal;
extern usg_res_messageDefaultTypeInternal _usg_res_message_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Empty* Arena::CreateMaybeMessage<::Empty>(Arena*);
template<> ::account_message* Arena::CreateMaybeMessage<::account_message>(Arena*);
template<> ::account_request* Arena::CreateMaybeMessage<::account_request>(Arena*);
template<> ::add_account_msg* Arena::CreateMaybeMessage<::add_account_msg>(Arena*);
template<> ::ekg_res_message* Arena::CreateMaybeMessage<::ekg_res_message>(Arena*);
template<> ::event_response* Arena::CreateMaybeMessage<::event_response>(Arena*);
template<> ::exam_message* Arena::CreateMaybeMessage<::exam_message>(Arena*);
template<> ::med_event_message* Arena::CreateMaybeMessage<::med_event_message>(Arena*);
template<> ::mor_res_message* Arena::CreateMaybeMessage<::mor_res_message>(Arena*);
template<> ::mri_res_message* Arena::CreateMaybeMessage<::mri_res_message>(Arena*);
template<> ::patient_message* Arena::CreateMaybeMessage<::patient_message>(Arena*);
template<> ::prescribtion_message* Arena::CreateMaybeMessage<::prescribtion_message>(Arena*);
template<> ::procedure_message* Arena::CreateMaybeMessage<::procedure_message>(Arena*);
template<> ::result* Arena::CreateMaybeMessage<::result>(Arena*);
template<> ::rtg_res_message* Arena::CreateMaybeMessage<::rtg_res_message>(Arena*);
template<> ::schedule_message* Arena::CreateMaybeMessage<::schedule_message>(Arena*);
template<> ::schedule_request* Arena::CreateMaybeMessage<::schedule_request>(Arena*);
template<> ::usg_res_message* Arena::CreateMaybeMessage<::usg_res_message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:result) */ {
 public:
  inline result() : result(nullptr) {}
  ~result() override;
  explicit PROTOBUF_CONSTEXPR result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  result(const result& from);
  result(result&& from) noexcept
    : result() {
    *this = ::std::move(from);
  }

  inline result& operator=(const result& from) {
    CopyFrom(from);
    return *this;
  }
  inline result& operator=(result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const result& default_instance() {
    return *internal_default_instance();
  }
  enum ResCase {
    kEkg = 1,
    kMor = 2,
    kRest = 3,
    RES_NOT_SET = 0,
  };

  static inline const result* internal_default_instance() {
    return reinterpret_cast<const result*>(
               &_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(result& a, result& b) {
    a.Swap(&b);
  }
  inline void Swap(result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const result& from) {
    result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "result";
  }
  protected:
  explicit result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEkgFieldNumber = 1,
    kMorFieldNumber = 2,
    kRestFieldNumber = 3,
  };
  // .ekg_res_message ekg = 1;
  bool has_ekg() const;
  private:
  bool _internal_has_ekg() const;
  public:
  void clear_ekg();
  const ::ekg_res_message& ekg() const;
  PROTOBUF_NODISCARD ::ekg_res_message* release_ekg();
  ::ekg_res_message* mutable_ekg();
  void set_allocated_ekg(::ekg_res_message* ekg);
  private:
  const ::ekg_res_message& _internal_ekg() const;
  ::ekg_res_message* _internal_mutable_ekg();
  public:
  void unsafe_arena_set_allocated_ekg(
      ::ekg_res_message* ekg);
  ::ekg_res_message* unsafe_arena_release_ekg();

  // .mor_res_message mor = 2;
  bool has_mor() const;
  private:
  bool _internal_has_mor() const;
  public:
  void clear_mor();
  const ::mor_res_message& mor() const;
  PROTOBUF_NODISCARD ::mor_res_message* release_mor();
  ::mor_res_message* mutable_mor();
  void set_allocated_mor(::mor_res_message* mor);
  private:
  const ::mor_res_message& _internal_mor() const;
  ::mor_res_message* _internal_mutable_mor();
  public:
  void unsafe_arena_set_allocated_mor(
      ::mor_res_message* mor);
  ::mor_res_message* unsafe_arena_release_mor();

  // .rtg_res_message rest = 3;
  bool has_rest() const;
  private:
  bool _internal_has_rest() const;
  public:
  void clear_rest();
  const ::rtg_res_message& rest() const;
  PROTOBUF_NODISCARD ::rtg_res_message* release_rest();
  ::rtg_res_message* mutable_rest();
  void set_allocated_rest(::rtg_res_message* rest);
  private:
  const ::rtg_res_message& _internal_rest() const;
  ::rtg_res_message* _internal_mutable_rest();
  public:
  void unsafe_arena_set_allocated_rest(
      ::rtg_res_message* rest);
  ::rtg_res_message* unsafe_arena_release_rest();

  void clear_res();
  ResCase res_case() const;
  // @@protoc_insertion_point(class_scope:result)
 private:
  class _Internal;
  void set_has_ekg();
  void set_has_mor();
  void set_has_rest();

  inline bool has_res() const;
  inline void clear_has_res();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResUnion {
      constexpr ResUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ekg_res_message* ekg_;
      ::mor_res_message* mor_;
      ::rtg_res_message* rest_;
    } res_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class event_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:event_response) */ {
 public:
  inline event_response() : event_response(nullptr) {}
  ~event_response() override;
  explicit PROTOBUF_CONSTEXPR event_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  event_response(const event_response& from);
  event_response(event_response&& from) noexcept
    : event_response() {
    *this = ::std::move(from);
  }

  inline event_response& operator=(const event_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline event_response& operator=(event_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const event_response& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kExam = 1,
    kProc = 2,
    kPres = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const event_response* internal_default_instance() {
    return reinterpret_cast<const event_response*>(
               &_event_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(event_response& a, event_response& b) {
    a.Swap(&b);
  }
  inline void Swap(event_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(event_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  event_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<event_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const event_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const event_response& from) {
    event_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(event_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "event_response";
  }
  protected:
  explicit event_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExamFieldNumber = 1,
    kProcFieldNumber = 2,
    kPresFieldNumber = 3,
  };
  // .exam_message exam = 1;
  bool has_exam() const;
  private:
  bool _internal_has_exam() const;
  public:
  void clear_exam();
  const ::exam_message& exam() const;
  PROTOBUF_NODISCARD ::exam_message* release_exam();
  ::exam_message* mutable_exam();
  void set_allocated_exam(::exam_message* exam);
  private:
  const ::exam_message& _internal_exam() const;
  ::exam_message* _internal_mutable_exam();
  public:
  void unsafe_arena_set_allocated_exam(
      ::exam_message* exam);
  ::exam_message* unsafe_arena_release_exam();

  // .procedure_message proc = 2;
  bool has_proc() const;
  private:
  bool _internal_has_proc() const;
  public:
  void clear_proc();
  const ::procedure_message& proc() const;
  PROTOBUF_NODISCARD ::procedure_message* release_proc();
  ::procedure_message* mutable_proc();
  void set_allocated_proc(::procedure_message* proc);
  private:
  const ::procedure_message& _internal_proc() const;
  ::procedure_message* _internal_mutable_proc();
  public:
  void unsafe_arena_set_allocated_proc(
      ::procedure_message* proc);
  ::procedure_message* unsafe_arena_release_proc();

  // .prescribtion_message pres = 3;
  bool has_pres() const;
  private:
  bool _internal_has_pres() const;
  public:
  void clear_pres();
  const ::prescribtion_message& pres() const;
  PROTOBUF_NODISCARD ::prescribtion_message* release_pres();
  ::prescribtion_message* mutable_pres();
  void set_allocated_pres(::prescribtion_message* pres);
  private:
  const ::prescribtion_message& _internal_pres() const;
  ::prescribtion_message* _internal_mutable_pres();
  public:
  void unsafe_arena_set_allocated_pres(
      ::prescribtion_message* pres);
  ::prescribtion_message* unsafe_arena_release_pres();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:event_response)
 private:
  class _Internal;
  void set_has_exam();
  void set_has_proc();
  void set_has_pres();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::exam_message* exam_;
      ::procedure_message* proc_;
      ::prescribtion_message* pres_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class add_account_msg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:add_account_msg) */ {
 public:
  inline add_account_msg() : add_account_msg(nullptr) {}
  ~add_account_msg() override;
  explicit PROTOBUF_CONSTEXPR add_account_msg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  add_account_msg(const add_account_msg& from);
  add_account_msg(add_account_msg&& from) noexcept
    : add_account_msg() {
    *this = ::std::move(from);
  }

  inline add_account_msg& operator=(const add_account_msg& from) {
    CopyFrom(from);
    return *this;
  }
  inline add_account_msg& operator=(add_account_msg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const add_account_msg& default_instance() {
    return *internal_default_instance();
  }
  static inline const add_account_msg* internal_default_instance() {
    return reinterpret_cast<const add_account_msg*>(
               &_add_account_msg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(add_account_msg& a, add_account_msg& b) {
    a.Swap(&b);
  }
  inline void Swap(add_account_msg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(add_account_msg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  add_account_msg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<add_account_msg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const add_account_msg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const add_account_msg& from) {
    add_account_msg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(add_account_msg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "add_account_msg";
  }
  protected:
  explicit add_account_msg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeselFieldNumber = 2,
    kAccountFieldNumber = 1,
  };
  // optional string pesel = 2;
  bool has_pesel() const;
  private:
  bool _internal_has_pesel() const;
  public:
  void clear_pesel();
  const std::string& pesel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pesel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pesel();
  PROTOBUF_NODISCARD std::string* release_pesel();
  void set_allocated_pesel(std::string* pesel);
  private:
  const std::string& _internal_pesel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pesel(const std::string& value);
  std::string* _internal_mutable_pesel();
  public:

  // .account_message account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::account_message& account() const;
  PROTOBUF_NODISCARD ::account_message* release_account();
  ::account_message* mutable_account();
  void set_allocated_account(::account_message* account);
  private:
  const ::account_message& _internal_account() const;
  ::account_message* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::account_message* account);
  ::account_message* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:add_account_msg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pesel_;
    ::account_message* account_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class schedule_request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedule_request) */ {
 public:
  inline schedule_request() : schedule_request(nullptr) {}
  ~schedule_request() override;
  explicit PROTOBUF_CONSTEXPR schedule_request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  schedule_request(const schedule_request& from);
  schedule_request(schedule_request&& from) noexcept
    : schedule_request() {
    *this = ::std::move(from);
  }

  inline schedule_request& operator=(const schedule_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline schedule_request& operator=(schedule_request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const schedule_request& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kVisit = 3,
    kExam = 4,
    kProc = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const schedule_request* internal_default_instance() {
    return reinterpret_cast<const schedule_request*>(
               &_schedule_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(schedule_request& a, schedule_request& b) {
    a.Swap(&b);
  }
  inline void Swap(schedule_request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(schedule_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  schedule_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<schedule_request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const schedule_request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const schedule_request& from) {
    schedule_request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(schedule_request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedule_request";
  }
  protected:
  explicit schedule_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleFieldNumber = 1,
    kPatientFieldNumber = 2,
    kVisitFieldNumber = 3,
    kExamFieldNumber = 4,
    kProcFieldNumber = 5,
  };
  // .schedule_message schedule = 1;
  bool has_schedule() const;
  private:
  bool _internal_has_schedule() const;
  public:
  void clear_schedule();
  const ::schedule_message& schedule() const;
  PROTOBUF_NODISCARD ::schedule_message* release_schedule();
  ::schedule_message* mutable_schedule();
  void set_allocated_schedule(::schedule_message* schedule);
  private:
  const ::schedule_message& _internal_schedule() const;
  ::schedule_message* _internal_mutable_schedule();
  public:
  void unsafe_arena_set_allocated_schedule(
      ::schedule_message* schedule);
  ::schedule_message* unsafe_arena_release_schedule();

  // .patient_message patient = 2;
  bool has_patient() const;
  private:
  bool _internal_has_patient() const;
  public:
  void clear_patient();
  const ::patient_message& patient() const;
  PROTOBUF_NODISCARD ::patient_message* release_patient();
  ::patient_message* mutable_patient();
  void set_allocated_patient(::patient_message* patient);
  private:
  const ::patient_message& _internal_patient() const;
  ::patient_message* _internal_mutable_patient();
  public:
  void unsafe_arena_set_allocated_patient(
      ::patient_message* patient);
  ::patient_message* unsafe_arena_release_patient();

  // .med_event_message visit = 3;
  bool has_visit() const;
  private:
  bool _internal_has_visit() const;
  public:
  void clear_visit();
  const ::med_event_message& visit() const;
  PROTOBUF_NODISCARD ::med_event_message* release_visit();
  ::med_event_message* mutable_visit();
  void set_allocated_visit(::med_event_message* visit);
  private:
  const ::med_event_message& _internal_visit() const;
  ::med_event_message* _internal_mutable_visit();
  public:
  void unsafe_arena_set_allocated_visit(
      ::med_event_message* visit);
  ::med_event_message* unsafe_arena_release_visit();

  // .exam_message exam = 4;
  bool has_exam() const;
  private:
  bool _internal_has_exam() const;
  public:
  void clear_exam();
  const ::exam_message& exam() const;
  PROTOBUF_NODISCARD ::exam_message* release_exam();
  ::exam_message* mutable_exam();
  void set_allocated_exam(::exam_message* exam);
  private:
  const ::exam_message& _internal_exam() const;
  ::exam_message* _internal_mutable_exam();
  public:
  void unsafe_arena_set_allocated_exam(
      ::exam_message* exam);
  ::exam_message* unsafe_arena_release_exam();

  // .procedure_message proc = 5;
  bool has_proc() const;
  private:
  bool _internal_has_proc() const;
  public:
  void clear_proc();
  const ::procedure_message& proc() const;
  PROTOBUF_NODISCARD ::procedure_message* release_proc();
  ::procedure_message* mutable_proc();
  void set_allocated_proc(::procedure_message* proc);
  private:
  const ::procedure_message& _internal_proc() const;
  ::procedure_message* _internal_mutable_proc();
  public:
  void unsafe_arena_set_allocated_proc(
      ::procedure_message* proc);
  ::procedure_message* unsafe_arena_release_proc();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:schedule_request)
 private:
  class _Internal;
  void set_has_visit();
  void set_has_exam();
  void set_has_proc();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::schedule_message* schedule_;
    ::patient_message* patient_;
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::med_event_message* visit_;
      ::exam_message* exam_;
      ::procedure_message* proc_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class account_request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:account_request) */ {
 public:
  inline account_request() : account_request(nullptr) {}
  ~account_request() override;
  explicit PROTOBUF_CONSTEXPR account_request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  account_request(const account_request& from);
  account_request(account_request&& from) noexcept
    : account_request() {
    *this = ::std::move(from);
  }

  inline account_request& operator=(const account_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline account_request& operator=(account_request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const account_request& default_instance() {
    return *internal_default_instance();
  }
  static inline const account_request* internal_default_instance() {
    return reinterpret_cast<const account_request*>(
               &_account_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(account_request& a, account_request& b) {
    a.Swap(&b);
  }
  inline void Swap(account_request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(account_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  account_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<account_request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const account_request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const account_request& from) {
    account_request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(account_request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "account_request";
  }
  protected:
  explicit account_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:account_request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class account_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:account_message) */ {
 public:
  inline account_message() : account_message(nullptr) {}
  ~account_message() override;
  explicit PROTOBUF_CONSTEXPR account_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  account_message(const account_message& from);
  account_message(account_message&& from) noexcept
    : account_message() {
    *this = ::std::move(from);
  }

  inline account_message& operator=(const account_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline account_message& operator=(account_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const account_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const account_message* internal_default_instance() {
    return reinterpret_cast<const account_message*>(
               &_account_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(account_message& a, account_message& b) {
    a.Swap(&b);
  }
  inline void Swap(account_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(account_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  account_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<account_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const account_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const account_message& from) {
    account_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(account_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "account_message";
  }
  protected:
  explicit account_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kNameFieldNumber = 3,
    kFamilynameFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string familyname = 4;
  void clear_familyname();
  const std::string& familyname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_familyname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_familyname();
  PROTOBUF_NODISCARD std::string* release_familyname();
  void set_allocated_familyname(std::string* familyname);
  private:
  const std::string& _internal_familyname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_familyname(const std::string& value);
  std::string* _internal_mutable_familyname();
  public:

  // string type = 5;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:account_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr familyname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class med_event_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:med_event_message) */ {
 public:
  inline med_event_message() : med_event_message(nullptr) {}
  ~med_event_message() override;
  explicit PROTOBUF_CONSTEXPR med_event_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  med_event_message(const med_event_message& from);
  med_event_message(med_event_message&& from) noexcept
    : med_event_message() {
    *this = ::std::move(from);
  }

  inline med_event_message& operator=(const med_event_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline med_event_message& operator=(med_event_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const med_event_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const med_event_message* internal_default_instance() {
    return reinterpret_cast<const med_event_message*>(
               &_med_event_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(med_event_message& a, med_event_message& b) {
    a.Swap(&b);
  }
  inline void Swap(med_event_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(med_event_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  med_event_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<med_event_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const med_event_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const med_event_message& from) {
    med_event_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(med_event_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "med_event_message";
  }
  protected:
  explicit med_event_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescribtionFieldNumber = 3,
    kRoomFieldNumber = 4,
    kTimeFieldNumber = 6,
    kNameFieldNumber = 2,
    kWhoPrescribedFieldNumber = 5,
    kIdFieldNumber = 1,
  };
  // string describtion = 3;
  void clear_describtion();
  const std::string& describtion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_describtion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_describtion();
  PROTOBUF_NODISCARD std::string* release_describtion();
  void set_allocated_describtion(std::string* describtion);
  private:
  const std::string& _internal_describtion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_describtion(const std::string& value);
  std::string* _internal_mutable_describtion();
  public:

  // string room = 4;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // string time = 6;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // .patient_message name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::patient_message& name() const;
  PROTOBUF_NODISCARD ::patient_message* release_name();
  ::patient_message* mutable_name();
  void set_allocated_name(::patient_message* name);
  private:
  const ::patient_message& _internal_name() const;
  ::patient_message* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::patient_message* name);
  ::patient_message* unsafe_arena_release_name();

  // .account_message who_prescribed = 5;
  bool has_who_prescribed() const;
  private:
  bool _internal_has_who_prescribed() const;
  public:
  void clear_who_prescribed();
  const ::account_message& who_prescribed() const;
  PROTOBUF_NODISCARD ::account_message* release_who_prescribed();
  ::account_message* mutable_who_prescribed();
  void set_allocated_who_prescribed(::account_message* who_prescribed);
  private:
  const ::account_message& _internal_who_prescribed() const;
  ::account_message* _internal_mutable_who_prescribed();
  public:
  void unsafe_arena_set_allocated_who_prescribed(
      ::account_message* who_prescribed);
  ::account_message* unsafe_arena_release_who_prescribed();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:med_event_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr describtion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::patient_message* name_;
    ::account_message* who_prescribed_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class exam_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exam_message) */ {
 public:
  inline exam_message() : exam_message(nullptr) {}
  ~exam_message() override;
  explicit PROTOBUF_CONSTEXPR exam_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  exam_message(const exam_message& from);
  exam_message(exam_message&& from) noexcept
    : exam_message() {
    *this = ::std::move(from);
  }

  inline exam_message& operator=(const exam_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline exam_message& operator=(exam_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const exam_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const exam_message* internal_default_instance() {
    return reinterpret_cast<const exam_message*>(
               &_exam_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(exam_message& a, exam_message& b) {
    a.Swap(&b);
  }
  inline void Swap(exam_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(exam_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  exam_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<exam_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const exam_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const exam_message& from) {
    exam_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(exam_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "exam_message";
  }
  protected:
  explicit exam_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhenFieldNumber = 3,
    kRoomFieldNumber = 5,
    kEventFieldNumber = 1,
    kWhoPerformsFieldNumber = 2,
    kResultIdFieldNumber = 4,
  };
  // string when = 3;
  void clear_when();
  const std::string& when() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_when(ArgT0&& arg0, ArgT... args);
  std::string* mutable_when();
  PROTOBUF_NODISCARD std::string* release_when();
  void set_allocated_when(std::string* when);
  private:
  const std::string& _internal_when() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_when(const std::string& value);
  std::string* _internal_mutable_when();
  public:

  // string room = 5;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // .med_event_message event = 1;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::med_event_message& event() const;
  PROTOBUF_NODISCARD ::med_event_message* release_event();
  ::med_event_message* mutable_event();
  void set_allocated_event(::med_event_message* event);
  private:
  const ::med_event_message& _internal_event() const;
  ::med_event_message* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::med_event_message* event);
  ::med_event_message* unsafe_arena_release_event();

  // .account_message who_performs = 2;
  bool has_who_performs() const;
  private:
  bool _internal_has_who_performs() const;
  public:
  void clear_who_performs();
  const ::account_message& who_performs() const;
  PROTOBUF_NODISCARD ::account_message* release_who_performs();
  ::account_message* mutable_who_performs();
  void set_allocated_who_performs(::account_message* who_performs);
  private:
  const ::account_message& _internal_who_performs() const;
  ::account_message* _internal_mutable_who_performs();
  public:
  void unsafe_arena_set_allocated_who_performs(
      ::account_message* who_performs);
  ::account_message* unsafe_arena_release_who_performs();

  // uint64 result_id = 4;
  void clear_result_id();
  uint64_t result_id() const;
  void set_result_id(uint64_t value);
  private:
  uint64_t _internal_result_id() const;
  void _internal_set_result_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:exam_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr when_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::med_event_message* event_;
    ::account_message* who_performs_;
    uint64_t result_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class ekg_res_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ekg_res_message) */ {
 public:
  inline ekg_res_message() : ekg_res_message(nullptr) {}
  ~ekg_res_message() override;
  explicit PROTOBUF_CONSTEXPR ekg_res_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ekg_res_message(const ekg_res_message& from);
  ekg_res_message(ekg_res_message&& from) noexcept
    : ekg_res_message() {
    *this = ::std::move(from);
  }

  inline ekg_res_message& operator=(const ekg_res_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline ekg_res_message& operator=(ekg_res_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ekg_res_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const ekg_res_message* internal_default_instance() {
    return reinterpret_cast<const ekg_res_message*>(
               &_ekg_res_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ekg_res_message& a, ekg_res_message& b) {
    a.Swap(&b);
  }
  inline void Swap(ekg_res_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ekg_res_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ekg_res_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ekg_res_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ekg_res_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ekg_res_message& from) {
    ekg_res_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ekg_res_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ekg_res_message";
  }
  protected:
  explicit ekg_res_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kRhytmFieldNumber = 2,
    kPrDelayFieldNumber = 3,
    kQrsFieldNumber = 4,
  };
  // .exam_message result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::exam_message& result_id() const;
  PROTOBUF_NODISCARD ::exam_message* release_result_id();
  ::exam_message* mutable_result_id();
  void set_allocated_result_id(::exam_message* result_id);
  private:
  const ::exam_message& _internal_result_id() const;
  ::exam_message* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::exam_message* result_id);
  ::exam_message* unsafe_arena_release_result_id();

  // uint32 rhytm = 2;
  void clear_rhytm();
  uint32_t rhytm() const;
  void set_rhytm(uint32_t value);
  private:
  uint32_t _internal_rhytm() const;
  void _internal_set_rhytm(uint32_t value);
  public:

  // uint32 pr_delay = 3;
  void clear_pr_delay();
  uint32_t pr_delay() const;
  void set_pr_delay(uint32_t value);
  private:
  uint32_t _internal_pr_delay() const;
  void _internal_set_pr_delay(uint32_t value);
  public:

  // uint32 qrs = 4;
  void clear_qrs();
  uint32_t qrs() const;
  void set_qrs(uint32_t value);
  private:
  uint32_t _internal_qrs() const;
  void _internal_set_qrs(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ekg_res_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::exam_message* result_id_;
    uint32_t rhytm_;
    uint32_t pr_delay_;
    uint32_t qrs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class mor_res_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mor_res_message) */ {
 public:
  inline mor_res_message() : mor_res_message(nullptr) {}
  ~mor_res_message() override;
  explicit PROTOBUF_CONSTEXPR mor_res_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mor_res_message(const mor_res_message& from);
  mor_res_message(mor_res_message&& from) noexcept
    : mor_res_message() {
    *this = ::std::move(from);
  }

  inline mor_res_message& operator=(const mor_res_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline mor_res_message& operator=(mor_res_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mor_res_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const mor_res_message* internal_default_instance() {
    return reinterpret_cast<const mor_res_message*>(
               &_mor_res_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(mor_res_message& a, mor_res_message& b) {
    a.Swap(&b);
  }
  inline void Swap(mor_res_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mor_res_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mor_res_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mor_res_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mor_res_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const mor_res_message& from) {
    mor_res_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mor_res_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mor_res_message";
  }
  protected:
  explicit mor_res_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kRbcFieldNumber = 2,
    kHbFieldNumber = 3,
    kWbcFieldNumber = 4,
    kPltFieldNumber = 5,
  };
  // .exam_message result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::exam_message& result_id() const;
  PROTOBUF_NODISCARD ::exam_message* release_result_id();
  ::exam_message* mutable_result_id();
  void set_allocated_result_id(::exam_message* result_id);
  private:
  const ::exam_message& _internal_result_id() const;
  ::exam_message* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::exam_message* result_id);
  ::exam_message* unsafe_arena_release_result_id();

  // uint32 rbc = 2;
  void clear_rbc();
  uint32_t rbc() const;
  void set_rbc(uint32_t value);
  private:
  uint32_t _internal_rbc() const;
  void _internal_set_rbc(uint32_t value);
  public:

  // uint32 hb = 3;
  void clear_hb();
  uint32_t hb() const;
  void set_hb(uint32_t value);
  private:
  uint32_t _internal_hb() const;
  void _internal_set_hb(uint32_t value);
  public:

  // uint32 wbc = 4;
  void clear_wbc();
  uint32_t wbc() const;
  void set_wbc(uint32_t value);
  private:
  uint32_t _internal_wbc() const;
  void _internal_set_wbc(uint32_t value);
  public:

  // uint32 plt = 5;
  void clear_plt();
  uint32_t plt() const;
  void set_plt(uint32_t value);
  private:
  uint32_t _internal_plt() const;
  void _internal_set_plt(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mor_res_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::exam_message* result_id_;
    uint32_t rbc_;
    uint32_t hb_;
    uint32_t wbc_;
    uint32_t plt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class mri_res_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mri_res_message) */ {
 public:
  inline mri_res_message() : mri_res_message(nullptr) {}
  ~mri_res_message() override;
  explicit PROTOBUF_CONSTEXPR mri_res_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mri_res_message(const mri_res_message& from);
  mri_res_message(mri_res_message&& from) noexcept
    : mri_res_message() {
    *this = ::std::move(from);
  }

  inline mri_res_message& operator=(const mri_res_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline mri_res_message& operator=(mri_res_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mri_res_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const mri_res_message* internal_default_instance() {
    return reinterpret_cast<const mri_res_message*>(
               &_mri_res_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(mri_res_message& a, mri_res_message& b) {
    a.Swap(&b);
  }
  inline void Swap(mri_res_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mri_res_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mri_res_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mri_res_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mri_res_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const mri_res_message& from) {
    mri_res_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mri_res_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mri_res_message";
  }
  protected:
  explicit mri_res_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kResultIdFieldNumber = 1,
  };
  // string result = 2;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // .exam_message result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::exam_message& result_id() const;
  PROTOBUF_NODISCARD ::exam_message* release_result_id();
  ::exam_message* mutable_result_id();
  void set_allocated_result_id(::exam_message* result_id);
  private:
  const ::exam_message& _internal_result_id() const;
  ::exam_message* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::exam_message* result_id);
  ::exam_message* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:mri_res_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    ::exam_message* result_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class rtg_res_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtg_res_message) */ {
 public:
  inline rtg_res_message() : rtg_res_message(nullptr) {}
  ~rtg_res_message() override;
  explicit PROTOBUF_CONSTEXPR rtg_res_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  rtg_res_message(const rtg_res_message& from);
  rtg_res_message(rtg_res_message&& from) noexcept
    : rtg_res_message() {
    *this = ::std::move(from);
  }

  inline rtg_res_message& operator=(const rtg_res_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline rtg_res_message& operator=(rtg_res_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const rtg_res_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const rtg_res_message* internal_default_instance() {
    return reinterpret_cast<const rtg_res_message*>(
               &_rtg_res_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(rtg_res_message& a, rtg_res_message& b) {
    a.Swap(&b);
  }
  inline void Swap(rtg_res_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rtg_res_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  rtg_res_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<rtg_res_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const rtg_res_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const rtg_res_message& from) {
    rtg_res_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rtg_res_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtg_res_message";
  }
  protected:
  explicit rtg_res_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kResultIdFieldNumber = 1,
  };
  // string result = 2;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // .exam_message result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::exam_message& result_id() const;
  PROTOBUF_NODISCARD ::exam_message* release_result_id();
  ::exam_message* mutable_result_id();
  void set_allocated_result_id(::exam_message* result_id);
  private:
  const ::exam_message& _internal_result_id() const;
  ::exam_message* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::exam_message* result_id);
  ::exam_message* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:rtg_res_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    ::exam_message* result_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class usg_res_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:usg_res_message) */ {
 public:
  inline usg_res_message() : usg_res_message(nullptr) {}
  ~usg_res_message() override;
  explicit PROTOBUF_CONSTEXPR usg_res_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  usg_res_message(const usg_res_message& from);
  usg_res_message(usg_res_message&& from) noexcept
    : usg_res_message() {
    *this = ::std::move(from);
  }

  inline usg_res_message& operator=(const usg_res_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline usg_res_message& operator=(usg_res_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const usg_res_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const usg_res_message* internal_default_instance() {
    return reinterpret_cast<const usg_res_message*>(
               &_usg_res_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(usg_res_message& a, usg_res_message& b) {
    a.Swap(&b);
  }
  inline void Swap(usg_res_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(usg_res_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  usg_res_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<usg_res_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const usg_res_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const usg_res_message& from) {
    usg_res_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(usg_res_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usg_res_message";
  }
  protected:
  explicit usg_res_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kResultIdFieldNumber = 1,
  };
  // string result = 2;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // .exam_message result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::exam_message& result_id() const;
  PROTOBUF_NODISCARD ::exam_message* release_result_id();
  ::exam_message* mutable_result_id();
  void set_allocated_result_id(::exam_message* result_id);
  private:
  const ::exam_message& _internal_result_id() const;
  ::exam_message* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::exam_message* result_id);
  ::exam_message* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:usg_res_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    ::exam_message* result_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class patient_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:patient_message) */ {
 public:
  inline patient_message() : patient_message(nullptr) {}
  ~patient_message() override;
  explicit PROTOBUF_CONSTEXPR patient_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  patient_message(const patient_message& from);
  patient_message(patient_message&& from) noexcept
    : patient_message() {
    *this = ::std::move(from);
  }

  inline patient_message& operator=(const patient_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline patient_message& operator=(patient_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const patient_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const patient_message* internal_default_instance() {
    return reinterpret_cast<const patient_message*>(
               &_patient_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(patient_message& a, patient_message& b) {
    a.Swap(&b);
  }
  inline void Swap(patient_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(patient_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  patient_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<patient_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const patient_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const patient_message& from) {
    patient_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(patient_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "patient_message";
  }
  protected:
  explicit patient_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeselFieldNumber = 1,
    kCityFieldNumber = 2,
    kStreetFieldNumber = 3,
    kPostcodeFieldNumber = 4,
    kBirthdateFieldNumber = 5,
    kUsernameFieldNumber = 6,
  };
  // string pesel = 1;
  void clear_pesel();
  const std::string& pesel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pesel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pesel();
  PROTOBUF_NODISCARD std::string* release_pesel();
  void set_allocated_pesel(std::string* pesel);
  private:
  const std::string& _internal_pesel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pesel(const std::string& value);
  std::string* _internal_mutable_pesel();
  public:

  // string city = 2;
  void clear_city();
  const std::string& city() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_city(ArgT0&& arg0, ArgT... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* city);
  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(const std::string& value);
  std::string* _internal_mutable_city();
  public:

  // string street = 3;
  void clear_street();
  const std::string& street() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_street(ArgT0&& arg0, ArgT... args);
  std::string* mutable_street();
  PROTOBUF_NODISCARD std::string* release_street();
  void set_allocated_street(std::string* street);
  private:
  const std::string& _internal_street() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_street(const std::string& value);
  std::string* _internal_mutable_street();
  public:

  // string postcode = 4;
  void clear_postcode();
  const std::string& postcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_postcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_postcode();
  PROTOBUF_NODISCARD std::string* release_postcode();
  void set_allocated_postcode(std::string* postcode);
  private:
  const std::string& _internal_postcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_postcode(const std::string& value);
  std::string* _internal_mutable_postcode();
  public:

  // string birthdate = 5;
  void clear_birthdate();
  const std::string& birthdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_birthdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_birthdate();
  PROTOBUF_NODISCARD std::string* release_birthdate();
  void set_allocated_birthdate(std::string* birthdate);
  private:
  const std::string& _internal_birthdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_birthdate(const std::string& value);
  std::string* _internal_mutable_birthdate();
  public:

  // .account_message username = 6;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const ::account_message& username() const;
  PROTOBUF_NODISCARD ::account_message* release_username();
  ::account_message* mutable_username();
  void set_allocated_username(::account_message* username);
  private:
  const ::account_message& _internal_username() const;
  ::account_message* _internal_mutable_username();
  public:
  void unsafe_arena_set_allocated_username(
      ::account_message* username);
  ::account_message* unsafe_arena_release_username();

  // @@protoc_insertion_point(class_scope:patient_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pesel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr city_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr street_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr postcode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr birthdate_;
    ::account_message* username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class prescribtion_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:prescribtion_message) */ {
 public:
  inline prescribtion_message() : prescribtion_message(nullptr) {}
  ~prescribtion_message() override;
  explicit PROTOBUF_CONSTEXPR prescribtion_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  prescribtion_message(const prescribtion_message& from);
  prescribtion_message(prescribtion_message&& from) noexcept
    : prescribtion_message() {
    *this = ::std::move(from);
  }

  inline prescribtion_message& operator=(const prescribtion_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline prescribtion_message& operator=(prescribtion_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const prescribtion_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const prescribtion_message* internal_default_instance() {
    return reinterpret_cast<const prescribtion_message*>(
               &_prescribtion_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(prescribtion_message& a, prescribtion_message& b) {
    a.Swap(&b);
  }
  inline void Swap(prescribtion_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(prescribtion_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  prescribtion_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<prescribtion_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const prescribtion_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const prescribtion_message& from) {
    prescribtion_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(prescribtion_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "prescribtion_message";
  }
  protected:
  explicit prescribtion_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMedicineFieldNumber = 2,
    kDoseFieldNumber = 3,
    kExpDateFieldNumber = 4,
    kEventFieldNumber = 1,
  };
  // string medicine = 2;
  void clear_medicine();
  const std::string& medicine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_medicine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_medicine();
  PROTOBUF_NODISCARD std::string* release_medicine();
  void set_allocated_medicine(std::string* medicine);
  private:
  const std::string& _internal_medicine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_medicine(const std::string& value);
  std::string* _internal_mutable_medicine();
  public:

  // string dose = 3;
  void clear_dose();
  const std::string& dose() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dose(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dose();
  PROTOBUF_NODISCARD std::string* release_dose();
  void set_allocated_dose(std::string* dose);
  private:
  const std::string& _internal_dose() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dose(const std::string& value);
  std::string* _internal_mutable_dose();
  public:

  // string exp_date = 4;
  void clear_exp_date();
  const std::string& exp_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exp_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exp_date();
  PROTOBUF_NODISCARD std::string* release_exp_date();
  void set_allocated_exp_date(std::string* exp_date);
  private:
  const std::string& _internal_exp_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exp_date(const std::string& value);
  std::string* _internal_mutable_exp_date();
  public:

  // .med_event_message event = 1;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::med_event_message& event() const;
  PROTOBUF_NODISCARD ::med_event_message* release_event();
  ::med_event_message* mutable_event();
  void set_allocated_event(::med_event_message* event);
  private:
  const ::med_event_message& _internal_event() const;
  ::med_event_message* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::med_event_message* event);
  ::med_event_message* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:prescribtion_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr medicine_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dose_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exp_date_;
    ::med_event_message* event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class procedure_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:procedure_message) */ {
 public:
  inline procedure_message() : procedure_message(nullptr) {}
  ~procedure_message() override;
  explicit PROTOBUF_CONSTEXPR procedure_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  procedure_message(const procedure_message& from);
  procedure_message(procedure_message&& from) noexcept
    : procedure_message() {
    *this = ::std::move(from);
  }

  inline procedure_message& operator=(const procedure_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline procedure_message& operator=(procedure_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const procedure_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const procedure_message* internal_default_instance() {
    return reinterpret_cast<const procedure_message*>(
               &_procedure_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(procedure_message& a, procedure_message& b) {
    a.Swap(&b);
  }
  inline void Swap(procedure_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(procedure_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  procedure_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<procedure_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const procedure_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const procedure_message& from) {
    procedure_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(procedure_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "procedure_message";
  }
  protected:
  explicit procedure_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhenFieldNumber = 3,
    kRoomFieldNumber = 4,
    kEventFieldNumber = 1,
    kWhoPerformsFieldNumber = 2,
  };
  // string when = 3;
  void clear_when();
  const std::string& when() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_when(ArgT0&& arg0, ArgT... args);
  std::string* mutable_when();
  PROTOBUF_NODISCARD std::string* release_when();
  void set_allocated_when(std::string* when);
  private:
  const std::string& _internal_when() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_when(const std::string& value);
  std::string* _internal_mutable_when();
  public:

  // string room = 4;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // .med_event_message event = 1;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::med_event_message& event() const;
  PROTOBUF_NODISCARD ::med_event_message* release_event();
  ::med_event_message* mutable_event();
  void set_allocated_event(::med_event_message* event);
  private:
  const ::med_event_message& _internal_event() const;
  ::med_event_message* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::med_event_message* event);
  ::med_event_message* unsafe_arena_release_event();

  // .account_message who_performs = 2;
  bool has_who_performs() const;
  private:
  bool _internal_has_who_performs() const;
  public:
  void clear_who_performs();
  const ::account_message& who_performs() const;
  PROTOBUF_NODISCARD ::account_message* release_who_performs();
  ::account_message* mutable_who_performs();
  void set_allocated_who_performs(::account_message* who_performs);
  private:
  const ::account_message& _internal_who_performs() const;
  ::account_message* _internal_mutable_who_performs();
  public:
  void unsafe_arena_set_allocated_who_performs(
      ::account_message* who_performs);
  ::account_message* unsafe_arena_release_who_performs();

  // @@protoc_insertion_point(class_scope:procedure_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr when_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::med_event_message* event_;
    ::account_message* who_performs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// -------------------------------------------------------------------

class schedule_message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedule_message) */ {
 public:
  inline schedule_message() : schedule_message(nullptr) {}
  ~schedule_message() override;
  explicit PROTOBUF_CONSTEXPR schedule_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  schedule_message(const schedule_message& from);
  schedule_message(schedule_message&& from) noexcept
    : schedule_message() {
    *this = ::std::move(from);
  }

  inline schedule_message& operator=(const schedule_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline schedule_message& operator=(schedule_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const schedule_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const schedule_message* internal_default_instance() {
    return reinterpret_cast<const schedule_message*>(
               &_schedule_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(schedule_message& a, schedule_message& b) {
    a.Swap(&b);
  }
  inline void Swap(schedule_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(schedule_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  schedule_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<schedule_message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const schedule_message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const schedule_message& from) {
    schedule_message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(schedule_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedule_message";
  }
  protected:
  explicit schedule_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 7,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kTypeFieldNumber = 5,
    kRoomFieldNumber = 6,
    kWhoFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // repeated .med_event_message events = 7;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::med_event_message* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::med_event_message >*
      mutable_events();
  private:
  const ::med_event_message& _internal_events(int index) const;
  ::med_event_message* _internal_add_events();
  public:
  const ::med_event_message& events(int index) const;
  ::med_event_message* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::med_event_message >&
      events() const;

  // string start = 3;
  void clear_start();
  const std::string& start() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start();
  PROTOBUF_NODISCARD std::string* release_start();
  void set_allocated_start(std::string* start);
  private:
  const std::string& _internal_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start(const std::string& value);
  std::string* _internal_mutable_start();
  public:

  // string end = 4;
  void clear_end();
  const std::string& end() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end();
  PROTOBUF_NODISCARD std::string* release_end();
  void set_allocated_end(std::string* end);
  private:
  const std::string& _internal_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end(const std::string& value);
  std::string* _internal_mutable_end();
  public:

  // string type = 5;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string room = 6;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // .account_message who = 1;
  bool has_who() const;
  private:
  bool _internal_has_who() const;
  public:
  void clear_who();
  const ::account_message& who() const;
  PROTOBUF_NODISCARD ::account_message* release_who();
  ::account_message* mutable_who();
  void set_allocated_who(::account_message* who);
  private:
  const ::account_message& _internal_who() const;
  ::account_message* _internal_mutable_who();
  public:
  void unsafe_arena_set_allocated_who(
      ::account_message* who);
  ::account_message* unsafe_arena_release_who();

  // uint64 id = 2;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:schedule_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::med_event_message > events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::account_message* who_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_com_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// result

// .ekg_res_message ekg = 1;
inline bool result::_internal_has_ekg() const {
  return res_case() == kEkg;
}
inline bool result::has_ekg() const {
  return _internal_has_ekg();
}
inline void result::set_has_ekg() {
  _impl_._oneof_case_[0] = kEkg;
}
inline void result::clear_ekg() {
  if (_internal_has_ekg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.res_.ekg_;
    }
    clear_has_res();
  }
}
inline ::ekg_res_message* result::release_ekg() {
  // @@protoc_insertion_point(field_release:result.ekg)
  if (_internal_has_ekg()) {
    clear_has_res();
    ::ekg_res_message* temp = _impl_.res_.ekg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.res_.ekg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ekg_res_message& result::_internal_ekg() const {
  return _internal_has_ekg()
      ? *_impl_.res_.ekg_
      : reinterpret_cast< ::ekg_res_message&>(::_ekg_res_message_default_instance_);
}
inline const ::ekg_res_message& result::ekg() const {
  // @@protoc_insertion_point(field_get:result.ekg)
  return _internal_ekg();
}
inline ::ekg_res_message* result::unsafe_arena_release_ekg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:result.ekg)
  if (_internal_has_ekg()) {
    clear_has_res();
    ::ekg_res_message* temp = _impl_.res_.ekg_;
    _impl_.res_.ekg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void result::unsafe_arena_set_allocated_ekg(::ekg_res_message* ekg) {
  clear_res();
  if (ekg) {
    set_has_ekg();
    _impl_.res_.ekg_ = ekg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:result.ekg)
}
inline ::ekg_res_message* result::_internal_mutable_ekg() {
  if (!_internal_has_ekg()) {
    clear_res();
    set_has_ekg();
    _impl_.res_.ekg_ = CreateMaybeMessage< ::ekg_res_message >(GetArenaForAllocation());
  }
  return _impl_.res_.ekg_;
}
inline ::ekg_res_message* result::mutable_ekg() {
  ::ekg_res_message* _msg = _internal_mutable_ekg();
  // @@protoc_insertion_point(field_mutable:result.ekg)
  return _msg;
}

// .mor_res_message mor = 2;
inline bool result::_internal_has_mor() const {
  return res_case() == kMor;
}
inline bool result::has_mor() const {
  return _internal_has_mor();
}
inline void result::set_has_mor() {
  _impl_._oneof_case_[0] = kMor;
}
inline void result::clear_mor() {
  if (_internal_has_mor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.res_.mor_;
    }
    clear_has_res();
  }
}
inline ::mor_res_message* result::release_mor() {
  // @@protoc_insertion_point(field_release:result.mor)
  if (_internal_has_mor()) {
    clear_has_res();
    ::mor_res_message* temp = _impl_.res_.mor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.res_.mor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mor_res_message& result::_internal_mor() const {
  return _internal_has_mor()
      ? *_impl_.res_.mor_
      : reinterpret_cast< ::mor_res_message&>(::_mor_res_message_default_instance_);
}
inline const ::mor_res_message& result::mor() const {
  // @@protoc_insertion_point(field_get:result.mor)
  return _internal_mor();
}
inline ::mor_res_message* result::unsafe_arena_release_mor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:result.mor)
  if (_internal_has_mor()) {
    clear_has_res();
    ::mor_res_message* temp = _impl_.res_.mor_;
    _impl_.res_.mor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void result::unsafe_arena_set_allocated_mor(::mor_res_message* mor) {
  clear_res();
  if (mor) {
    set_has_mor();
    _impl_.res_.mor_ = mor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:result.mor)
}
inline ::mor_res_message* result::_internal_mutable_mor() {
  if (!_internal_has_mor()) {
    clear_res();
    set_has_mor();
    _impl_.res_.mor_ = CreateMaybeMessage< ::mor_res_message >(GetArenaForAllocation());
  }
  return _impl_.res_.mor_;
}
inline ::mor_res_message* result::mutable_mor() {
  ::mor_res_message* _msg = _internal_mutable_mor();
  // @@protoc_insertion_point(field_mutable:result.mor)
  return _msg;
}

// .rtg_res_message rest = 3;
inline bool result::_internal_has_rest() const {
  return res_case() == kRest;
}
inline bool result::has_rest() const {
  return _internal_has_rest();
}
inline void result::set_has_rest() {
  _impl_._oneof_case_[0] = kRest;
}
inline void result::clear_rest() {
  if (_internal_has_rest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.res_.rest_;
    }
    clear_has_res();
  }
}
inline ::rtg_res_message* result::release_rest() {
  // @@protoc_insertion_point(field_release:result.rest)
  if (_internal_has_rest()) {
    clear_has_res();
    ::rtg_res_message* temp = _impl_.res_.rest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.res_.rest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtg_res_message& result::_internal_rest() const {
  return _internal_has_rest()
      ? *_impl_.res_.rest_
      : reinterpret_cast< ::rtg_res_message&>(::_rtg_res_message_default_instance_);
}
inline const ::rtg_res_message& result::rest() const {
  // @@protoc_insertion_point(field_get:result.rest)
  return _internal_rest();
}
inline ::rtg_res_message* result::unsafe_arena_release_rest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:result.rest)
  if (_internal_has_rest()) {
    clear_has_res();
    ::rtg_res_message* temp = _impl_.res_.rest_;
    _impl_.res_.rest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void result::unsafe_arena_set_allocated_rest(::rtg_res_message* rest) {
  clear_res();
  if (rest) {
    set_has_rest();
    _impl_.res_.rest_ = rest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:result.rest)
}
inline ::rtg_res_message* result::_internal_mutable_rest() {
  if (!_internal_has_rest()) {
    clear_res();
    set_has_rest();
    _impl_.res_.rest_ = CreateMaybeMessage< ::rtg_res_message >(GetArenaForAllocation());
  }
  return _impl_.res_.rest_;
}
inline ::rtg_res_message* result::mutable_rest() {
  ::rtg_res_message* _msg = _internal_mutable_rest();
  // @@protoc_insertion_point(field_mutable:result.rest)
  return _msg;
}

inline bool result::has_res() const {
  return res_case() != RES_NOT_SET;
}
inline void result::clear_has_res() {
  _impl_._oneof_case_[0] = RES_NOT_SET;
}
inline result::ResCase result::res_case() const {
  return result::ResCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// event_response

// .exam_message exam = 1;
inline bool event_response::_internal_has_exam() const {
  return event_case() == kExam;
}
inline bool event_response::has_exam() const {
  return _internal_has_exam();
}
inline void event_response::set_has_exam() {
  _impl_._oneof_case_[0] = kExam;
}
inline void event_response::clear_exam() {
  if (_internal_has_exam()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.exam_;
    }
    clear_has_event();
  }
}
inline ::exam_message* event_response::release_exam() {
  // @@protoc_insertion_point(field_release:event_response.exam)
  if (_internal_has_exam()) {
    clear_has_event();
    ::exam_message* temp = _impl_.event_.exam_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.exam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::exam_message& event_response::_internal_exam() const {
  return _internal_has_exam()
      ? *_impl_.event_.exam_
      : reinterpret_cast< ::exam_message&>(::_exam_message_default_instance_);
}
inline const ::exam_message& event_response::exam() const {
  // @@protoc_insertion_point(field_get:event_response.exam)
  return _internal_exam();
}
inline ::exam_message* event_response::unsafe_arena_release_exam() {
  // @@protoc_insertion_point(field_unsafe_arena_release:event_response.exam)
  if (_internal_has_exam()) {
    clear_has_event();
    ::exam_message* temp = _impl_.event_.exam_;
    _impl_.event_.exam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void event_response::unsafe_arena_set_allocated_exam(::exam_message* exam) {
  clear_event();
  if (exam) {
    set_has_exam();
    _impl_.event_.exam_ = exam;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:event_response.exam)
}
inline ::exam_message* event_response::_internal_mutable_exam() {
  if (!_internal_has_exam()) {
    clear_event();
    set_has_exam();
    _impl_.event_.exam_ = CreateMaybeMessage< ::exam_message >(GetArenaForAllocation());
  }
  return _impl_.event_.exam_;
}
inline ::exam_message* event_response::mutable_exam() {
  ::exam_message* _msg = _internal_mutable_exam();
  // @@protoc_insertion_point(field_mutable:event_response.exam)
  return _msg;
}

// .procedure_message proc = 2;
inline bool event_response::_internal_has_proc() const {
  return event_case() == kProc;
}
inline bool event_response::has_proc() const {
  return _internal_has_proc();
}
inline void event_response::set_has_proc() {
  _impl_._oneof_case_[0] = kProc;
}
inline void event_response::clear_proc() {
  if (_internal_has_proc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.proc_;
    }
    clear_has_event();
  }
}
inline ::procedure_message* event_response::release_proc() {
  // @@protoc_insertion_point(field_release:event_response.proc)
  if (_internal_has_proc()) {
    clear_has_event();
    ::procedure_message* temp = _impl_.event_.proc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.proc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::procedure_message& event_response::_internal_proc() const {
  return _internal_has_proc()
      ? *_impl_.event_.proc_
      : reinterpret_cast< ::procedure_message&>(::_procedure_message_default_instance_);
}
inline const ::procedure_message& event_response::proc() const {
  // @@protoc_insertion_point(field_get:event_response.proc)
  return _internal_proc();
}
inline ::procedure_message* event_response::unsafe_arena_release_proc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:event_response.proc)
  if (_internal_has_proc()) {
    clear_has_event();
    ::procedure_message* temp = _impl_.event_.proc_;
    _impl_.event_.proc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void event_response::unsafe_arena_set_allocated_proc(::procedure_message* proc) {
  clear_event();
  if (proc) {
    set_has_proc();
    _impl_.event_.proc_ = proc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:event_response.proc)
}
inline ::procedure_message* event_response::_internal_mutable_proc() {
  if (!_internal_has_proc()) {
    clear_event();
    set_has_proc();
    _impl_.event_.proc_ = CreateMaybeMessage< ::procedure_message >(GetArenaForAllocation());
  }
  return _impl_.event_.proc_;
}
inline ::procedure_message* event_response::mutable_proc() {
  ::procedure_message* _msg = _internal_mutable_proc();
  // @@protoc_insertion_point(field_mutable:event_response.proc)
  return _msg;
}

// .prescribtion_message pres = 3;
inline bool event_response::_internal_has_pres() const {
  return event_case() == kPres;
}
inline bool event_response::has_pres() const {
  return _internal_has_pres();
}
inline void event_response::set_has_pres() {
  _impl_._oneof_case_[0] = kPres;
}
inline void event_response::clear_pres() {
  if (_internal_has_pres()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.pres_;
    }
    clear_has_event();
  }
}
inline ::prescribtion_message* event_response::release_pres() {
  // @@protoc_insertion_point(field_release:event_response.pres)
  if (_internal_has_pres()) {
    clear_has_event();
    ::prescribtion_message* temp = _impl_.event_.pres_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.pres_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::prescribtion_message& event_response::_internal_pres() const {
  return _internal_has_pres()
      ? *_impl_.event_.pres_
      : reinterpret_cast< ::prescribtion_message&>(::_prescribtion_message_default_instance_);
}
inline const ::prescribtion_message& event_response::pres() const {
  // @@protoc_insertion_point(field_get:event_response.pres)
  return _internal_pres();
}
inline ::prescribtion_message* event_response::unsafe_arena_release_pres() {
  // @@protoc_insertion_point(field_unsafe_arena_release:event_response.pres)
  if (_internal_has_pres()) {
    clear_has_event();
    ::prescribtion_message* temp = _impl_.event_.pres_;
    _impl_.event_.pres_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void event_response::unsafe_arena_set_allocated_pres(::prescribtion_message* pres) {
  clear_event();
  if (pres) {
    set_has_pres();
    _impl_.event_.pres_ = pres;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:event_response.pres)
}
inline ::prescribtion_message* event_response::_internal_mutable_pres() {
  if (!_internal_has_pres()) {
    clear_event();
    set_has_pres();
    _impl_.event_.pres_ = CreateMaybeMessage< ::prescribtion_message >(GetArenaForAllocation());
  }
  return _impl_.event_.pres_;
}
inline ::prescribtion_message* event_response::mutable_pres() {
  ::prescribtion_message* _msg = _internal_mutable_pres();
  // @@protoc_insertion_point(field_mutable:event_response.pres)
  return _msg;
}

inline bool event_response::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void event_response::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline event_response::EventCase event_response::event_case() const {
  return event_response::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// add_account_msg

// .account_message account = 1;
inline bool add_account_msg::_internal_has_account() const {
  return this != internal_default_instance() && _impl_.account_ != nullptr;
}
inline bool add_account_msg::has_account() const {
  return _internal_has_account();
}
inline void add_account_msg::clear_account() {
  if (GetArenaForAllocation() == nullptr && _impl_.account_ != nullptr) {
    delete _impl_.account_;
  }
  _impl_.account_ = nullptr;
}
inline const ::account_message& add_account_msg::_internal_account() const {
  const ::account_message* p = _impl_.account_;
  return p != nullptr ? *p : reinterpret_cast<const ::account_message&>(
      ::_account_message_default_instance_);
}
inline const ::account_message& add_account_msg::account() const {
  // @@protoc_insertion_point(field_get:add_account_msg.account)
  return _internal_account();
}
inline void add_account_msg::unsafe_arena_set_allocated_account(
    ::account_message* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_);
  }
  _impl_.account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:add_account_msg.account)
}
inline ::account_message* add_account_msg::release_account() {
  
  ::account_message* temp = _impl_.account_;
  _impl_.account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::account_message* add_account_msg::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:add_account_msg.account)
  
  ::account_message* temp = _impl_.account_;
  _impl_.account_ = nullptr;
  return temp;
}
inline ::account_message* add_account_msg::_internal_mutable_account() {
  
  if (_impl_.account_ == nullptr) {
    auto* p = CreateMaybeMessage<::account_message>(GetArenaForAllocation());
    _impl_.account_ = p;
  }
  return _impl_.account_;
}
inline ::account_message* add_account_msg::mutable_account() {
  ::account_message* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:add_account_msg.account)
  return _msg;
}
inline void add_account_msg::set_allocated_account(::account_message* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account);
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.account_ = account;
  // @@protoc_insertion_point(field_set_allocated:add_account_msg.account)
}

// optional string pesel = 2;
inline bool add_account_msg::_internal_has_pesel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool add_account_msg::has_pesel() const {
  return _internal_has_pesel();
}
inline void add_account_msg::clear_pesel() {
  _impl_.pesel_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& add_account_msg::pesel() const {
  // @@protoc_insertion_point(field_get:add_account_msg.pesel)
  return _internal_pesel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void add_account_msg::set_pesel(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pesel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:add_account_msg.pesel)
}
inline std::string* add_account_msg::mutable_pesel() {
  std::string* _s = _internal_mutable_pesel();
  // @@protoc_insertion_point(field_mutable:add_account_msg.pesel)
  return _s;
}
inline const std::string& add_account_msg::_internal_pesel() const {
  return _impl_.pesel_.Get();
}
inline void add_account_msg::_internal_set_pesel(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pesel_.Set(value, GetArenaForAllocation());
}
inline std::string* add_account_msg::_internal_mutable_pesel() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pesel_.Mutable(GetArenaForAllocation());
}
inline std::string* add_account_msg::release_pesel() {
  // @@protoc_insertion_point(field_release:add_account_msg.pesel)
  if (!_internal_has_pesel()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pesel_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pesel_.IsDefault()) {
    _impl_.pesel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void add_account_msg::set_allocated_pesel(std::string* pesel) {
  if (pesel != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pesel_.SetAllocated(pesel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pesel_.IsDefault()) {
    _impl_.pesel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:add_account_msg.pesel)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// schedule_request

// .schedule_message schedule = 1;
inline bool schedule_request::_internal_has_schedule() const {
  return this != internal_default_instance() && _impl_.schedule_ != nullptr;
}
inline bool schedule_request::has_schedule() const {
  return _internal_has_schedule();
}
inline void schedule_request::clear_schedule() {
  if (GetArenaForAllocation() == nullptr && _impl_.schedule_ != nullptr) {
    delete _impl_.schedule_;
  }
  _impl_.schedule_ = nullptr;
}
inline const ::schedule_message& schedule_request::_internal_schedule() const {
  const ::schedule_message* p = _impl_.schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::schedule_message&>(
      ::_schedule_message_default_instance_);
}
inline const ::schedule_message& schedule_request::schedule() const {
  // @@protoc_insertion_point(field_get:schedule_request.schedule)
  return _internal_schedule();
}
inline void schedule_request::unsafe_arena_set_allocated_schedule(
    ::schedule_message* schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_);
  }
  _impl_.schedule_ = schedule;
  if (schedule) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:schedule_request.schedule)
}
inline ::schedule_message* schedule_request::release_schedule() {
  
  ::schedule_message* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::schedule_message* schedule_request::unsafe_arena_release_schedule() {
  // @@protoc_insertion_point(field_release:schedule_request.schedule)
  
  ::schedule_message* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
  return temp;
}
inline ::schedule_message* schedule_request::_internal_mutable_schedule() {
  
  if (_impl_.schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedule_message>(GetArenaForAllocation());
    _impl_.schedule_ = p;
  }
  return _impl_.schedule_;
}
inline ::schedule_message* schedule_request::mutable_schedule() {
  ::schedule_message* _msg = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:schedule_request.schedule)
  return _msg;
}
inline void schedule_request::set_allocated_schedule(::schedule_message* schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schedule_;
  }
  if (schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schedule);
    if (message_arena != submessage_arena) {
      schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:schedule_request.schedule)
}

// .patient_message patient = 2;
inline bool schedule_request::_internal_has_patient() const {
  return this != internal_default_instance() && _impl_.patient_ != nullptr;
}
inline bool schedule_request::has_patient() const {
  return _internal_has_patient();
}
inline void schedule_request::clear_patient() {
  if (GetArenaForAllocation() == nullptr && _impl_.patient_ != nullptr) {
    delete _impl_.patient_;
  }
  _impl_.patient_ = nullptr;
}
inline const ::patient_message& schedule_request::_internal_patient() const {
  const ::patient_message* p = _impl_.patient_;
  return p != nullptr ? *p : reinterpret_cast<const ::patient_message&>(
      ::_patient_message_default_instance_);
}
inline const ::patient_message& schedule_request::patient() const {
  // @@protoc_insertion_point(field_get:schedule_request.patient)
  return _internal_patient();
}
inline void schedule_request::unsafe_arena_set_allocated_patient(
    ::patient_message* patient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.patient_);
  }
  _impl_.patient_ = patient;
  if (patient) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:schedule_request.patient)
}
inline ::patient_message* schedule_request::release_patient() {
  
  ::patient_message* temp = _impl_.patient_;
  _impl_.patient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::patient_message* schedule_request::unsafe_arena_release_patient() {
  // @@protoc_insertion_point(field_release:schedule_request.patient)
  
  ::patient_message* temp = _impl_.patient_;
  _impl_.patient_ = nullptr;
  return temp;
}
inline ::patient_message* schedule_request::_internal_mutable_patient() {
  
  if (_impl_.patient_ == nullptr) {
    auto* p = CreateMaybeMessage<::patient_message>(GetArenaForAllocation());
    _impl_.patient_ = p;
  }
  return _impl_.patient_;
}
inline ::patient_message* schedule_request::mutable_patient() {
  ::patient_message* _msg = _internal_mutable_patient();
  // @@protoc_insertion_point(field_mutable:schedule_request.patient)
  return _msg;
}
inline void schedule_request::set_allocated_patient(::patient_message* patient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.patient_;
  }
  if (patient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(patient);
    if (message_arena != submessage_arena) {
      patient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, patient, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.patient_ = patient;
  // @@protoc_insertion_point(field_set_allocated:schedule_request.patient)
}

// .med_event_message visit = 3;
inline bool schedule_request::_internal_has_visit() const {
  return event_case() == kVisit;
}
inline bool schedule_request::has_visit() const {
  return _internal_has_visit();
}
inline void schedule_request::set_has_visit() {
  _impl_._oneof_case_[0] = kVisit;
}
inline void schedule_request::clear_visit() {
  if (_internal_has_visit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.visit_;
    }
    clear_has_event();
  }
}
inline ::med_event_message* schedule_request::release_visit() {
  // @@protoc_insertion_point(field_release:schedule_request.visit)
  if (_internal_has_visit()) {
    clear_has_event();
    ::med_event_message* temp = _impl_.event_.visit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.visit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::med_event_message& schedule_request::_internal_visit() const {
  return _internal_has_visit()
      ? *_impl_.event_.visit_
      : reinterpret_cast< ::med_event_message&>(::_med_event_message_default_instance_);
}
inline const ::med_event_message& schedule_request::visit() const {
  // @@protoc_insertion_point(field_get:schedule_request.visit)
  return _internal_visit();
}
inline ::med_event_message* schedule_request::unsafe_arena_release_visit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:schedule_request.visit)
  if (_internal_has_visit()) {
    clear_has_event();
    ::med_event_message* temp = _impl_.event_.visit_;
    _impl_.event_.visit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void schedule_request::unsafe_arena_set_allocated_visit(::med_event_message* visit) {
  clear_event();
  if (visit) {
    set_has_visit();
    _impl_.event_.visit_ = visit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:schedule_request.visit)
}
inline ::med_event_message* schedule_request::_internal_mutable_visit() {
  if (!_internal_has_visit()) {
    clear_event();
    set_has_visit();
    _impl_.event_.visit_ = CreateMaybeMessage< ::med_event_message >(GetArenaForAllocation());
  }
  return _impl_.event_.visit_;
}
inline ::med_event_message* schedule_request::mutable_visit() {
  ::med_event_message* _msg = _internal_mutable_visit();
  // @@protoc_insertion_point(field_mutable:schedule_request.visit)
  return _msg;
}

// .exam_message exam = 4;
inline bool schedule_request::_internal_has_exam() const {
  return event_case() == kExam;
}
inline bool schedule_request::has_exam() const {
  return _internal_has_exam();
}
inline void schedule_request::set_has_exam() {
  _impl_._oneof_case_[0] = kExam;
}
inline void schedule_request::clear_exam() {
  if (_internal_has_exam()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.exam_;
    }
    clear_has_event();
  }
}
inline ::exam_message* schedule_request::release_exam() {
  // @@protoc_insertion_point(field_release:schedule_request.exam)
  if (_internal_has_exam()) {
    clear_has_event();
    ::exam_message* temp = _impl_.event_.exam_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.exam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::exam_message& schedule_request::_internal_exam() const {
  return _internal_has_exam()
      ? *_impl_.event_.exam_
      : reinterpret_cast< ::exam_message&>(::_exam_message_default_instance_);
}
inline const ::exam_message& schedule_request::exam() const {
  // @@protoc_insertion_point(field_get:schedule_request.exam)
  return _internal_exam();
}
inline ::exam_message* schedule_request::unsafe_arena_release_exam() {
  // @@protoc_insertion_point(field_unsafe_arena_release:schedule_request.exam)
  if (_internal_has_exam()) {
    clear_has_event();
    ::exam_message* temp = _impl_.event_.exam_;
    _impl_.event_.exam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void schedule_request::unsafe_arena_set_allocated_exam(::exam_message* exam) {
  clear_event();
  if (exam) {
    set_has_exam();
    _impl_.event_.exam_ = exam;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:schedule_request.exam)
}
inline ::exam_message* schedule_request::_internal_mutable_exam() {
  if (!_internal_has_exam()) {
    clear_event();
    set_has_exam();
    _impl_.event_.exam_ = CreateMaybeMessage< ::exam_message >(GetArenaForAllocation());
  }
  return _impl_.event_.exam_;
}
inline ::exam_message* schedule_request::mutable_exam() {
  ::exam_message* _msg = _internal_mutable_exam();
  // @@protoc_insertion_point(field_mutable:schedule_request.exam)
  return _msg;
}

// .procedure_message proc = 5;
inline bool schedule_request::_internal_has_proc() const {
  return event_case() == kProc;
}
inline bool schedule_request::has_proc() const {
  return _internal_has_proc();
}
inline void schedule_request::set_has_proc() {
  _impl_._oneof_case_[0] = kProc;
}
inline void schedule_request::clear_proc() {
  if (_internal_has_proc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.proc_;
    }
    clear_has_event();
  }
}
inline ::procedure_message* schedule_request::release_proc() {
  // @@protoc_insertion_point(field_release:schedule_request.proc)
  if (_internal_has_proc()) {
    clear_has_event();
    ::procedure_message* temp = _impl_.event_.proc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.proc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::procedure_message& schedule_request::_internal_proc() const {
  return _internal_has_proc()
      ? *_impl_.event_.proc_
      : reinterpret_cast< ::procedure_message&>(::_procedure_message_default_instance_);
}
inline const ::procedure_message& schedule_request::proc() const {
  // @@protoc_insertion_point(field_get:schedule_request.proc)
  return _internal_proc();
}
inline ::procedure_message* schedule_request::unsafe_arena_release_proc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:schedule_request.proc)
  if (_internal_has_proc()) {
    clear_has_event();
    ::procedure_message* temp = _impl_.event_.proc_;
    _impl_.event_.proc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void schedule_request::unsafe_arena_set_allocated_proc(::procedure_message* proc) {
  clear_event();
  if (proc) {
    set_has_proc();
    _impl_.event_.proc_ = proc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:schedule_request.proc)
}
inline ::procedure_message* schedule_request::_internal_mutable_proc() {
  if (!_internal_has_proc()) {
    clear_event();
    set_has_proc();
    _impl_.event_.proc_ = CreateMaybeMessage< ::procedure_message >(GetArenaForAllocation());
  }
  return _impl_.event_.proc_;
}
inline ::procedure_message* schedule_request::mutable_proc() {
  ::procedure_message* _msg = _internal_mutable_proc();
  // @@protoc_insertion_point(field_mutable:schedule_request.proc)
  return _msg;
}

inline bool schedule_request::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void schedule_request::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline schedule_request::EventCase schedule_request::event_case() const {
  return schedule_request::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// account_request

// string username = 1;
inline void account_request::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& account_request::username() const {
  // @@protoc_insertion_point(field_get:account_request.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void account_request::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:account_request.username)
}
inline std::string* account_request::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:account_request.username)
  return _s;
}
inline const std::string& account_request::_internal_username() const {
  return _impl_.username_.Get();
}
inline void account_request::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* account_request::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* account_request::release_username() {
  // @@protoc_insertion_point(field_release:account_request.username)
  return _impl_.username_.Release();
}
inline void account_request::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:account_request.username)
}

// string password = 2;
inline void account_request::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& account_request::password() const {
  // @@protoc_insertion_point(field_get:account_request.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void account_request::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:account_request.password)
}
inline std::string* account_request::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:account_request.password)
  return _s;
}
inline const std::string& account_request::_internal_password() const {
  return _impl_.password_.Get();
}
inline void account_request::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* account_request::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* account_request::release_password() {
  // @@protoc_insertion_point(field_release:account_request.password)
  return _impl_.password_.Release();
}
inline void account_request::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:account_request.password)
}

// -------------------------------------------------------------------

// account_message

// string username = 1;
inline void account_message::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& account_message::username() const {
  // @@protoc_insertion_point(field_get:account_message.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void account_message::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:account_message.username)
}
inline std::string* account_message::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:account_message.username)
  return _s;
}
inline const std::string& account_message::_internal_username() const {
  return _impl_.username_.Get();
}
inline void account_message::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* account_message::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* account_message::release_username() {
  // @@protoc_insertion_point(field_release:account_message.username)
  return _impl_.username_.Release();
}
inline void account_message::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:account_message.username)
}

// string password = 2;
inline void account_message::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& account_message::password() const {
  // @@protoc_insertion_point(field_get:account_message.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void account_message::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:account_message.password)
}
inline std::string* account_message::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:account_message.password)
  return _s;
}
inline const std::string& account_message::_internal_password() const {
  return _impl_.password_.Get();
}
inline void account_message::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* account_message::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* account_message::release_password() {
  // @@protoc_insertion_point(field_release:account_message.password)
  return _impl_.password_.Release();
}
inline void account_message::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:account_message.password)
}

// string name = 3;
inline void account_message::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& account_message::name() const {
  // @@protoc_insertion_point(field_get:account_message.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void account_message::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:account_message.name)
}
inline std::string* account_message::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:account_message.name)
  return _s;
}
inline const std::string& account_message::_internal_name() const {
  return _impl_.name_.Get();
}
inline void account_message::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* account_message::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* account_message::release_name() {
  // @@protoc_insertion_point(field_release:account_message.name)
  return _impl_.name_.Release();
}
inline void account_message::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:account_message.name)
}

// string familyname = 4;
inline void account_message::clear_familyname() {
  _impl_.familyname_.ClearToEmpty();
}
inline const std::string& account_message::familyname() const {
  // @@protoc_insertion_point(field_get:account_message.familyname)
  return _internal_familyname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void account_message::set_familyname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.familyname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:account_message.familyname)
}
inline std::string* account_message::mutable_familyname() {
  std::string* _s = _internal_mutable_familyname();
  // @@protoc_insertion_point(field_mutable:account_message.familyname)
  return _s;
}
inline const std::string& account_message::_internal_familyname() const {
  return _impl_.familyname_.Get();
}
inline void account_message::_internal_set_familyname(const std::string& value) {
  
  _impl_.familyname_.Set(value, GetArenaForAllocation());
}
inline std::string* account_message::_internal_mutable_familyname() {
  
  return _impl_.familyname_.Mutable(GetArenaForAllocation());
}
inline std::string* account_message::release_familyname() {
  // @@protoc_insertion_point(field_release:account_message.familyname)
  return _impl_.familyname_.Release();
}
inline void account_message::set_allocated_familyname(std::string* familyname) {
  if (familyname != nullptr) {
    
  } else {
    
  }
  _impl_.familyname_.SetAllocated(familyname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.familyname_.IsDefault()) {
    _impl_.familyname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:account_message.familyname)
}

// string type = 5;
inline void account_message::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& account_message::type() const {
  // @@protoc_insertion_point(field_get:account_message.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void account_message::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:account_message.type)
}
inline std::string* account_message::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:account_message.type)
  return _s;
}
inline const std::string& account_message::_internal_type() const {
  return _impl_.type_.Get();
}
inline void account_message::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* account_message::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* account_message::release_type() {
  // @@protoc_insertion_point(field_release:account_message.type)
  return _impl_.type_.Release();
}
inline void account_message::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:account_message.type)
}

// -------------------------------------------------------------------

// med_event_message

// uint64 id = 1;
inline void med_event_message::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t med_event_message::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t med_event_message::id() const {
  // @@protoc_insertion_point(field_get:med_event_message.id)
  return _internal_id();
}
inline void med_event_message::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void med_event_message::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:med_event_message.id)
}

// .patient_message name = 2;
inline bool med_event_message::_internal_has_name() const {
  return this != internal_default_instance() && _impl_.name_ != nullptr;
}
inline bool med_event_message::has_name() const {
  return _internal_has_name();
}
inline void med_event_message::clear_name() {
  if (GetArenaForAllocation() == nullptr && _impl_.name_ != nullptr) {
    delete _impl_.name_;
  }
  _impl_.name_ = nullptr;
}
inline const ::patient_message& med_event_message::_internal_name() const {
  const ::patient_message* p = _impl_.name_;
  return p != nullptr ? *p : reinterpret_cast<const ::patient_message&>(
      ::_patient_message_default_instance_);
}
inline const ::patient_message& med_event_message::name() const {
  // @@protoc_insertion_point(field_get:med_event_message.name)
  return _internal_name();
}
inline void med_event_message::unsafe_arena_set_allocated_name(
    ::patient_message* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  _impl_.name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:med_event_message.name)
}
inline ::patient_message* med_event_message::release_name() {
  
  ::patient_message* temp = _impl_.name_;
  _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::patient_message* med_event_message::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:med_event_message.name)
  
  ::patient_message* temp = _impl_.name_;
  _impl_.name_ = nullptr;
  return temp;
}
inline ::patient_message* med_event_message::_internal_mutable_name() {
  
  if (_impl_.name_ == nullptr) {
    auto* p = CreateMaybeMessage<::patient_message>(GetArenaForAllocation());
    _impl_.name_ = p;
  }
  return _impl_.name_;
}
inline ::patient_message* med_event_message::mutable_name() {
  ::patient_message* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:med_event_message.name)
  return _msg;
}
inline void med_event_message::set_allocated_name(::patient_message* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name);
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_set_allocated:med_event_message.name)
}

// string describtion = 3;
inline void med_event_message::clear_describtion() {
  _impl_.describtion_.ClearToEmpty();
}
inline const std::string& med_event_message::describtion() const {
  // @@protoc_insertion_point(field_get:med_event_message.describtion)
  return _internal_describtion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void med_event_message::set_describtion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.describtion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:med_event_message.describtion)
}
inline std::string* med_event_message::mutable_describtion() {
  std::string* _s = _internal_mutable_describtion();
  // @@protoc_insertion_point(field_mutable:med_event_message.describtion)
  return _s;
}
inline const std::string& med_event_message::_internal_describtion() const {
  return _impl_.describtion_.Get();
}
inline void med_event_message::_internal_set_describtion(const std::string& value) {
  
  _impl_.describtion_.Set(value, GetArenaForAllocation());
}
inline std::string* med_event_message::_internal_mutable_describtion() {
  
  return _impl_.describtion_.Mutable(GetArenaForAllocation());
}
inline std::string* med_event_message::release_describtion() {
  // @@protoc_insertion_point(field_release:med_event_message.describtion)
  return _impl_.describtion_.Release();
}
inline void med_event_message::set_allocated_describtion(std::string* describtion) {
  if (describtion != nullptr) {
    
  } else {
    
  }
  _impl_.describtion_.SetAllocated(describtion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.describtion_.IsDefault()) {
    _impl_.describtion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:med_event_message.describtion)
}

// string room = 4;
inline void med_event_message::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& med_event_message::room() const {
  // @@protoc_insertion_point(field_get:med_event_message.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void med_event_message::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:med_event_message.room)
}
inline std::string* med_event_message::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:med_event_message.room)
  return _s;
}
inline const std::string& med_event_message::_internal_room() const {
  return _impl_.room_.Get();
}
inline void med_event_message::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* med_event_message::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* med_event_message::release_room() {
  // @@protoc_insertion_point(field_release:med_event_message.room)
  return _impl_.room_.Release();
}
inline void med_event_message::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:med_event_message.room)
}

// .account_message who_prescribed = 5;
inline bool med_event_message::_internal_has_who_prescribed() const {
  return this != internal_default_instance() && _impl_.who_prescribed_ != nullptr;
}
inline bool med_event_message::has_who_prescribed() const {
  return _internal_has_who_prescribed();
}
inline void med_event_message::clear_who_prescribed() {
  if (GetArenaForAllocation() == nullptr && _impl_.who_prescribed_ != nullptr) {
    delete _impl_.who_prescribed_;
  }
  _impl_.who_prescribed_ = nullptr;
}
inline const ::account_message& med_event_message::_internal_who_prescribed() const {
  const ::account_message* p = _impl_.who_prescribed_;
  return p != nullptr ? *p : reinterpret_cast<const ::account_message&>(
      ::_account_message_default_instance_);
}
inline const ::account_message& med_event_message::who_prescribed() const {
  // @@protoc_insertion_point(field_get:med_event_message.who_prescribed)
  return _internal_who_prescribed();
}
inline void med_event_message::unsafe_arena_set_allocated_who_prescribed(
    ::account_message* who_prescribed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.who_prescribed_);
  }
  _impl_.who_prescribed_ = who_prescribed;
  if (who_prescribed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:med_event_message.who_prescribed)
}
inline ::account_message* med_event_message::release_who_prescribed() {
  
  ::account_message* temp = _impl_.who_prescribed_;
  _impl_.who_prescribed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::account_message* med_event_message::unsafe_arena_release_who_prescribed() {
  // @@protoc_insertion_point(field_release:med_event_message.who_prescribed)
  
  ::account_message* temp = _impl_.who_prescribed_;
  _impl_.who_prescribed_ = nullptr;
  return temp;
}
inline ::account_message* med_event_message::_internal_mutable_who_prescribed() {
  
  if (_impl_.who_prescribed_ == nullptr) {
    auto* p = CreateMaybeMessage<::account_message>(GetArenaForAllocation());
    _impl_.who_prescribed_ = p;
  }
  return _impl_.who_prescribed_;
}
inline ::account_message* med_event_message::mutable_who_prescribed() {
  ::account_message* _msg = _internal_mutable_who_prescribed();
  // @@protoc_insertion_point(field_mutable:med_event_message.who_prescribed)
  return _msg;
}
inline void med_event_message::set_allocated_who_prescribed(::account_message* who_prescribed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.who_prescribed_;
  }
  if (who_prescribed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(who_prescribed);
    if (message_arena != submessage_arena) {
      who_prescribed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, who_prescribed, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.who_prescribed_ = who_prescribed;
  // @@protoc_insertion_point(field_set_allocated:med_event_message.who_prescribed)
}

// string time = 6;
inline void med_event_message::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& med_event_message::time() const {
  // @@protoc_insertion_point(field_get:med_event_message.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void med_event_message::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:med_event_message.time)
}
inline std::string* med_event_message::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:med_event_message.time)
  return _s;
}
inline const std::string& med_event_message::_internal_time() const {
  return _impl_.time_.Get();
}
inline void med_event_message::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* med_event_message::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* med_event_message::release_time() {
  // @@protoc_insertion_point(field_release:med_event_message.time)
  return _impl_.time_.Release();
}
inline void med_event_message::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:med_event_message.time)
}

// -------------------------------------------------------------------

// exam_message

// .med_event_message event = 1;
inline bool exam_message::_internal_has_event() const {
  return this != internal_default_instance() && _impl_.event_ != nullptr;
}
inline bool exam_message::has_event() const {
  return _internal_has_event();
}
inline void exam_message::clear_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.event_ != nullptr) {
    delete _impl_.event_;
  }
  _impl_.event_ = nullptr;
}
inline const ::med_event_message& exam_message::_internal_event() const {
  const ::med_event_message* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::med_event_message&>(
      ::_med_event_message_default_instance_);
}
inline const ::med_event_message& exam_message::event() const {
  // @@protoc_insertion_point(field_get:exam_message.event)
  return _internal_event();
}
inline void exam_message::unsafe_arena_set_allocated_event(
    ::med_event_message* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exam_message.event)
}
inline ::med_event_message* exam_message::release_event() {
  
  ::med_event_message* temp = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::med_event_message* exam_message::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:exam_message.event)
  
  ::med_event_message* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::med_event_message* exam_message::_internal_mutable_event() {
  
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::med_event_message>(GetArenaForAllocation());
    _impl_.event_ = p;
  }
  return _impl_.event_;
}
inline ::med_event_message* exam_message::mutable_event() {
  ::med_event_message* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:exam_message.event)
  return _msg;
}
inline void exam_message::set_allocated_event(::med_event_message* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_ = event;
  // @@protoc_insertion_point(field_set_allocated:exam_message.event)
}

// .account_message who_performs = 2;
inline bool exam_message::_internal_has_who_performs() const {
  return this != internal_default_instance() && _impl_.who_performs_ != nullptr;
}
inline bool exam_message::has_who_performs() const {
  return _internal_has_who_performs();
}
inline void exam_message::clear_who_performs() {
  if (GetArenaForAllocation() == nullptr && _impl_.who_performs_ != nullptr) {
    delete _impl_.who_performs_;
  }
  _impl_.who_performs_ = nullptr;
}
inline const ::account_message& exam_message::_internal_who_performs() const {
  const ::account_message* p = _impl_.who_performs_;
  return p != nullptr ? *p : reinterpret_cast<const ::account_message&>(
      ::_account_message_default_instance_);
}
inline const ::account_message& exam_message::who_performs() const {
  // @@protoc_insertion_point(field_get:exam_message.who_performs)
  return _internal_who_performs();
}
inline void exam_message::unsafe_arena_set_allocated_who_performs(
    ::account_message* who_performs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.who_performs_);
  }
  _impl_.who_performs_ = who_performs;
  if (who_performs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exam_message.who_performs)
}
inline ::account_message* exam_message::release_who_performs() {
  
  ::account_message* temp = _impl_.who_performs_;
  _impl_.who_performs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::account_message* exam_message::unsafe_arena_release_who_performs() {
  // @@protoc_insertion_point(field_release:exam_message.who_performs)
  
  ::account_message* temp = _impl_.who_performs_;
  _impl_.who_performs_ = nullptr;
  return temp;
}
inline ::account_message* exam_message::_internal_mutable_who_performs() {
  
  if (_impl_.who_performs_ == nullptr) {
    auto* p = CreateMaybeMessage<::account_message>(GetArenaForAllocation());
    _impl_.who_performs_ = p;
  }
  return _impl_.who_performs_;
}
inline ::account_message* exam_message::mutable_who_performs() {
  ::account_message* _msg = _internal_mutable_who_performs();
  // @@protoc_insertion_point(field_mutable:exam_message.who_performs)
  return _msg;
}
inline void exam_message::set_allocated_who_performs(::account_message* who_performs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.who_performs_;
  }
  if (who_performs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(who_performs);
    if (message_arena != submessage_arena) {
      who_performs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, who_performs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.who_performs_ = who_performs;
  // @@protoc_insertion_point(field_set_allocated:exam_message.who_performs)
}

// string when = 3;
inline void exam_message::clear_when() {
  _impl_.when_.ClearToEmpty();
}
inline const std::string& exam_message::when() const {
  // @@protoc_insertion_point(field_get:exam_message.when)
  return _internal_when();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void exam_message::set_when(ArgT0&& arg0, ArgT... args) {
 
 _impl_.when_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exam_message.when)
}
inline std::string* exam_message::mutable_when() {
  std::string* _s = _internal_mutable_when();
  // @@protoc_insertion_point(field_mutable:exam_message.when)
  return _s;
}
inline const std::string& exam_message::_internal_when() const {
  return _impl_.when_.Get();
}
inline void exam_message::_internal_set_when(const std::string& value) {
  
  _impl_.when_.Set(value, GetArenaForAllocation());
}
inline std::string* exam_message::_internal_mutable_when() {
  
  return _impl_.when_.Mutable(GetArenaForAllocation());
}
inline std::string* exam_message::release_when() {
  // @@protoc_insertion_point(field_release:exam_message.when)
  return _impl_.when_.Release();
}
inline void exam_message::set_allocated_when(std::string* when) {
  if (when != nullptr) {
    
  } else {
    
  }
  _impl_.when_.SetAllocated(when, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.when_.IsDefault()) {
    _impl_.when_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exam_message.when)
}

// uint64 result_id = 4;
inline void exam_message::clear_result_id() {
  _impl_.result_id_ = uint64_t{0u};
}
inline uint64_t exam_message::_internal_result_id() const {
  return _impl_.result_id_;
}
inline uint64_t exam_message::result_id() const {
  // @@protoc_insertion_point(field_get:exam_message.result_id)
  return _internal_result_id();
}
inline void exam_message::_internal_set_result_id(uint64_t value) {
  
  _impl_.result_id_ = value;
}
inline void exam_message::set_result_id(uint64_t value) {
  _internal_set_result_id(value);
  // @@protoc_insertion_point(field_set:exam_message.result_id)
}

// string room = 5;
inline void exam_message::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& exam_message::room() const {
  // @@protoc_insertion_point(field_get:exam_message.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void exam_message::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exam_message.room)
}
inline std::string* exam_message::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:exam_message.room)
  return _s;
}
inline const std::string& exam_message::_internal_room() const {
  return _impl_.room_.Get();
}
inline void exam_message::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* exam_message::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* exam_message::release_room() {
  // @@protoc_insertion_point(field_release:exam_message.room)
  return _impl_.room_.Release();
}
inline void exam_message::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exam_message.room)
}

// -------------------------------------------------------------------

// ekg_res_message

// .exam_message result_id = 1;
inline bool ekg_res_message::_internal_has_result_id() const {
  return this != internal_default_instance() && _impl_.result_id_ != nullptr;
}
inline bool ekg_res_message::has_result_id() const {
  return _internal_has_result_id();
}
inline void ekg_res_message::clear_result_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_id_ != nullptr) {
    delete _impl_.result_id_;
  }
  _impl_.result_id_ = nullptr;
}
inline const ::exam_message& ekg_res_message::_internal_result_id() const {
  const ::exam_message* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exam_message&>(
      ::_exam_message_default_instance_);
}
inline const ::exam_message& ekg_res_message::result_id() const {
  // @@protoc_insertion_point(field_get:ekg_res_message.result_id)
  return _internal_result_id();
}
inline void ekg_res_message::unsafe_arena_set_allocated_result_id(
    ::exam_message* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ekg_res_message.result_id)
}
inline ::exam_message* ekg_res_message::release_result_id() {
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exam_message* ekg_res_message::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:ekg_res_message.result_id)
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::exam_message* ekg_res_message::_internal_mutable_result_id() {
  
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exam_message>(GetArenaForAllocation());
    _impl_.result_id_ = p;
  }
  return _impl_.result_id_;
}
inline ::exam_message* ekg_res_message::mutable_result_id() {
  ::exam_message* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:ekg_res_message.result_id)
  return _msg;
}
inline void ekg_res_message::set_allocated_result_id(::exam_message* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_id_;
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result_id);
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:ekg_res_message.result_id)
}

// uint32 rhytm = 2;
inline void ekg_res_message::clear_rhytm() {
  _impl_.rhytm_ = 0u;
}
inline uint32_t ekg_res_message::_internal_rhytm() const {
  return _impl_.rhytm_;
}
inline uint32_t ekg_res_message::rhytm() const {
  // @@protoc_insertion_point(field_get:ekg_res_message.rhytm)
  return _internal_rhytm();
}
inline void ekg_res_message::_internal_set_rhytm(uint32_t value) {
  
  _impl_.rhytm_ = value;
}
inline void ekg_res_message::set_rhytm(uint32_t value) {
  _internal_set_rhytm(value);
  // @@protoc_insertion_point(field_set:ekg_res_message.rhytm)
}

// uint32 pr_delay = 3;
inline void ekg_res_message::clear_pr_delay() {
  _impl_.pr_delay_ = 0u;
}
inline uint32_t ekg_res_message::_internal_pr_delay() const {
  return _impl_.pr_delay_;
}
inline uint32_t ekg_res_message::pr_delay() const {
  // @@protoc_insertion_point(field_get:ekg_res_message.pr_delay)
  return _internal_pr_delay();
}
inline void ekg_res_message::_internal_set_pr_delay(uint32_t value) {
  
  _impl_.pr_delay_ = value;
}
inline void ekg_res_message::set_pr_delay(uint32_t value) {
  _internal_set_pr_delay(value);
  // @@protoc_insertion_point(field_set:ekg_res_message.pr_delay)
}

// uint32 qrs = 4;
inline void ekg_res_message::clear_qrs() {
  _impl_.qrs_ = 0u;
}
inline uint32_t ekg_res_message::_internal_qrs() const {
  return _impl_.qrs_;
}
inline uint32_t ekg_res_message::qrs() const {
  // @@protoc_insertion_point(field_get:ekg_res_message.qrs)
  return _internal_qrs();
}
inline void ekg_res_message::_internal_set_qrs(uint32_t value) {
  
  _impl_.qrs_ = value;
}
inline void ekg_res_message::set_qrs(uint32_t value) {
  _internal_set_qrs(value);
  // @@protoc_insertion_point(field_set:ekg_res_message.qrs)
}

// -------------------------------------------------------------------

// mor_res_message

// .exam_message result_id = 1;
inline bool mor_res_message::_internal_has_result_id() const {
  return this != internal_default_instance() && _impl_.result_id_ != nullptr;
}
inline bool mor_res_message::has_result_id() const {
  return _internal_has_result_id();
}
inline void mor_res_message::clear_result_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_id_ != nullptr) {
    delete _impl_.result_id_;
  }
  _impl_.result_id_ = nullptr;
}
inline const ::exam_message& mor_res_message::_internal_result_id() const {
  const ::exam_message* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exam_message&>(
      ::_exam_message_default_instance_);
}
inline const ::exam_message& mor_res_message::result_id() const {
  // @@protoc_insertion_point(field_get:mor_res_message.result_id)
  return _internal_result_id();
}
inline void mor_res_message::unsafe_arena_set_allocated_result_id(
    ::exam_message* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mor_res_message.result_id)
}
inline ::exam_message* mor_res_message::release_result_id() {
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exam_message* mor_res_message::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:mor_res_message.result_id)
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::exam_message* mor_res_message::_internal_mutable_result_id() {
  
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exam_message>(GetArenaForAllocation());
    _impl_.result_id_ = p;
  }
  return _impl_.result_id_;
}
inline ::exam_message* mor_res_message::mutable_result_id() {
  ::exam_message* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:mor_res_message.result_id)
  return _msg;
}
inline void mor_res_message::set_allocated_result_id(::exam_message* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_id_;
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result_id);
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:mor_res_message.result_id)
}

// uint32 rbc = 2;
inline void mor_res_message::clear_rbc() {
  _impl_.rbc_ = 0u;
}
inline uint32_t mor_res_message::_internal_rbc() const {
  return _impl_.rbc_;
}
inline uint32_t mor_res_message::rbc() const {
  // @@protoc_insertion_point(field_get:mor_res_message.rbc)
  return _internal_rbc();
}
inline void mor_res_message::_internal_set_rbc(uint32_t value) {
  
  _impl_.rbc_ = value;
}
inline void mor_res_message::set_rbc(uint32_t value) {
  _internal_set_rbc(value);
  // @@protoc_insertion_point(field_set:mor_res_message.rbc)
}

// uint32 hb = 3;
inline void mor_res_message::clear_hb() {
  _impl_.hb_ = 0u;
}
inline uint32_t mor_res_message::_internal_hb() const {
  return _impl_.hb_;
}
inline uint32_t mor_res_message::hb() const {
  // @@protoc_insertion_point(field_get:mor_res_message.hb)
  return _internal_hb();
}
inline void mor_res_message::_internal_set_hb(uint32_t value) {
  
  _impl_.hb_ = value;
}
inline void mor_res_message::set_hb(uint32_t value) {
  _internal_set_hb(value);
  // @@protoc_insertion_point(field_set:mor_res_message.hb)
}

// uint32 wbc = 4;
inline void mor_res_message::clear_wbc() {
  _impl_.wbc_ = 0u;
}
inline uint32_t mor_res_message::_internal_wbc() const {
  return _impl_.wbc_;
}
inline uint32_t mor_res_message::wbc() const {
  // @@protoc_insertion_point(field_get:mor_res_message.wbc)
  return _internal_wbc();
}
inline void mor_res_message::_internal_set_wbc(uint32_t value) {
  
  _impl_.wbc_ = value;
}
inline void mor_res_message::set_wbc(uint32_t value) {
  _internal_set_wbc(value);
  // @@protoc_insertion_point(field_set:mor_res_message.wbc)
}

// uint32 plt = 5;
inline void mor_res_message::clear_plt() {
  _impl_.plt_ = 0u;
}
inline uint32_t mor_res_message::_internal_plt() const {
  return _impl_.plt_;
}
inline uint32_t mor_res_message::plt() const {
  // @@protoc_insertion_point(field_get:mor_res_message.plt)
  return _internal_plt();
}
inline void mor_res_message::_internal_set_plt(uint32_t value) {
  
  _impl_.plt_ = value;
}
inline void mor_res_message::set_plt(uint32_t value) {
  _internal_set_plt(value);
  // @@protoc_insertion_point(field_set:mor_res_message.plt)
}

// -------------------------------------------------------------------

// mri_res_message

// .exam_message result_id = 1;
inline bool mri_res_message::_internal_has_result_id() const {
  return this != internal_default_instance() && _impl_.result_id_ != nullptr;
}
inline bool mri_res_message::has_result_id() const {
  return _internal_has_result_id();
}
inline void mri_res_message::clear_result_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_id_ != nullptr) {
    delete _impl_.result_id_;
  }
  _impl_.result_id_ = nullptr;
}
inline const ::exam_message& mri_res_message::_internal_result_id() const {
  const ::exam_message* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exam_message&>(
      ::_exam_message_default_instance_);
}
inline const ::exam_message& mri_res_message::result_id() const {
  // @@protoc_insertion_point(field_get:mri_res_message.result_id)
  return _internal_result_id();
}
inline void mri_res_message::unsafe_arena_set_allocated_result_id(
    ::exam_message* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mri_res_message.result_id)
}
inline ::exam_message* mri_res_message::release_result_id() {
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exam_message* mri_res_message::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:mri_res_message.result_id)
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::exam_message* mri_res_message::_internal_mutable_result_id() {
  
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exam_message>(GetArenaForAllocation());
    _impl_.result_id_ = p;
  }
  return _impl_.result_id_;
}
inline ::exam_message* mri_res_message::mutable_result_id() {
  ::exam_message* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:mri_res_message.result_id)
  return _msg;
}
inline void mri_res_message::set_allocated_result_id(::exam_message* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_id_;
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result_id);
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:mri_res_message.result_id)
}

// string result = 2;
inline void mri_res_message::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& mri_res_message::result() const {
  // @@protoc_insertion_point(field_get:mri_res_message.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mri_res_message::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mri_res_message.result)
}
inline std::string* mri_res_message::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:mri_res_message.result)
  return _s;
}
inline const std::string& mri_res_message::_internal_result() const {
  return _impl_.result_.Get();
}
inline void mri_res_message::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* mri_res_message::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* mri_res_message::release_result() {
  // @@protoc_insertion_point(field_release:mri_res_message.result)
  return _impl_.result_.Release();
}
inline void mri_res_message::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mri_res_message.result)
}

// -------------------------------------------------------------------

// rtg_res_message

// .exam_message result_id = 1;
inline bool rtg_res_message::_internal_has_result_id() const {
  return this != internal_default_instance() && _impl_.result_id_ != nullptr;
}
inline bool rtg_res_message::has_result_id() const {
  return _internal_has_result_id();
}
inline void rtg_res_message::clear_result_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_id_ != nullptr) {
    delete _impl_.result_id_;
  }
  _impl_.result_id_ = nullptr;
}
inline const ::exam_message& rtg_res_message::_internal_result_id() const {
  const ::exam_message* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exam_message&>(
      ::_exam_message_default_instance_);
}
inline const ::exam_message& rtg_res_message::result_id() const {
  // @@protoc_insertion_point(field_get:rtg_res_message.result_id)
  return _internal_result_id();
}
inline void rtg_res_message::unsafe_arena_set_allocated_result_id(
    ::exam_message* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtg_res_message.result_id)
}
inline ::exam_message* rtg_res_message::release_result_id() {
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exam_message* rtg_res_message::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:rtg_res_message.result_id)
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::exam_message* rtg_res_message::_internal_mutable_result_id() {
  
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exam_message>(GetArenaForAllocation());
    _impl_.result_id_ = p;
  }
  return _impl_.result_id_;
}
inline ::exam_message* rtg_res_message::mutable_result_id() {
  ::exam_message* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:rtg_res_message.result_id)
  return _msg;
}
inline void rtg_res_message::set_allocated_result_id(::exam_message* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_id_;
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result_id);
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:rtg_res_message.result_id)
}

// string result = 2;
inline void rtg_res_message::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& rtg_res_message::result() const {
  // @@protoc_insertion_point(field_get:rtg_res_message.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void rtg_res_message::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtg_res_message.result)
}
inline std::string* rtg_res_message::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:rtg_res_message.result)
  return _s;
}
inline const std::string& rtg_res_message::_internal_result() const {
  return _impl_.result_.Get();
}
inline void rtg_res_message::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* rtg_res_message::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* rtg_res_message::release_result() {
  // @@protoc_insertion_point(field_release:rtg_res_message.result)
  return _impl_.result_.Release();
}
inline void rtg_res_message::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtg_res_message.result)
}

// -------------------------------------------------------------------

// usg_res_message

// .exam_message result_id = 1;
inline bool usg_res_message::_internal_has_result_id() const {
  return this != internal_default_instance() && _impl_.result_id_ != nullptr;
}
inline bool usg_res_message::has_result_id() const {
  return _internal_has_result_id();
}
inline void usg_res_message::clear_result_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_id_ != nullptr) {
    delete _impl_.result_id_;
  }
  _impl_.result_id_ = nullptr;
}
inline const ::exam_message& usg_res_message::_internal_result_id() const {
  const ::exam_message* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exam_message&>(
      ::_exam_message_default_instance_);
}
inline const ::exam_message& usg_res_message::result_id() const {
  // @@protoc_insertion_point(field_get:usg_res_message.result_id)
  return _internal_result_id();
}
inline void usg_res_message::unsafe_arena_set_allocated_result_id(
    ::exam_message* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:usg_res_message.result_id)
}
inline ::exam_message* usg_res_message::release_result_id() {
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exam_message* usg_res_message::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:usg_res_message.result_id)
  
  ::exam_message* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::exam_message* usg_res_message::_internal_mutable_result_id() {
  
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exam_message>(GetArenaForAllocation());
    _impl_.result_id_ = p;
  }
  return _impl_.result_id_;
}
inline ::exam_message* usg_res_message::mutable_result_id() {
  ::exam_message* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:usg_res_message.result_id)
  return _msg;
}
inline void usg_res_message::set_allocated_result_id(::exam_message* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_id_;
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result_id);
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:usg_res_message.result_id)
}

// string result = 2;
inline void usg_res_message::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& usg_res_message::result() const {
  // @@protoc_insertion_point(field_get:usg_res_message.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void usg_res_message::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:usg_res_message.result)
}
inline std::string* usg_res_message::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:usg_res_message.result)
  return _s;
}
inline const std::string& usg_res_message::_internal_result() const {
  return _impl_.result_.Get();
}
inline void usg_res_message::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* usg_res_message::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* usg_res_message::release_result() {
  // @@protoc_insertion_point(field_release:usg_res_message.result)
  return _impl_.result_.Release();
}
inline void usg_res_message::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:usg_res_message.result)
}

// -------------------------------------------------------------------

// patient_message

// string pesel = 1;
inline void patient_message::clear_pesel() {
  _impl_.pesel_.ClearToEmpty();
}
inline const std::string& patient_message::pesel() const {
  // @@protoc_insertion_point(field_get:patient_message.pesel)
  return _internal_pesel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void patient_message::set_pesel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pesel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:patient_message.pesel)
}
inline std::string* patient_message::mutable_pesel() {
  std::string* _s = _internal_mutable_pesel();
  // @@protoc_insertion_point(field_mutable:patient_message.pesel)
  return _s;
}
inline const std::string& patient_message::_internal_pesel() const {
  return _impl_.pesel_.Get();
}
inline void patient_message::_internal_set_pesel(const std::string& value) {
  
  _impl_.pesel_.Set(value, GetArenaForAllocation());
}
inline std::string* patient_message::_internal_mutable_pesel() {
  
  return _impl_.pesel_.Mutable(GetArenaForAllocation());
}
inline std::string* patient_message::release_pesel() {
  // @@protoc_insertion_point(field_release:patient_message.pesel)
  return _impl_.pesel_.Release();
}
inline void patient_message::set_allocated_pesel(std::string* pesel) {
  if (pesel != nullptr) {
    
  } else {
    
  }
  _impl_.pesel_.SetAllocated(pesel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pesel_.IsDefault()) {
    _impl_.pesel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:patient_message.pesel)
}

// string city = 2;
inline void patient_message::clear_city() {
  _impl_.city_.ClearToEmpty();
}
inline const std::string& patient_message::city() const {
  // @@protoc_insertion_point(field_get:patient_message.city)
  return _internal_city();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void patient_message::set_city(ArgT0&& arg0, ArgT... args) {
 
 _impl_.city_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:patient_message.city)
}
inline std::string* patient_message::mutable_city() {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:patient_message.city)
  return _s;
}
inline const std::string& patient_message::_internal_city() const {
  return _impl_.city_.Get();
}
inline void patient_message::_internal_set_city(const std::string& value) {
  
  _impl_.city_.Set(value, GetArenaForAllocation());
}
inline std::string* patient_message::_internal_mutable_city() {
  
  return _impl_.city_.Mutable(GetArenaForAllocation());
}
inline std::string* patient_message::release_city() {
  // @@protoc_insertion_point(field_release:patient_message.city)
  return _impl_.city_.Release();
}
inline void patient_message::set_allocated_city(std::string* city) {
  if (city != nullptr) {
    
  } else {
    
  }
  _impl_.city_.SetAllocated(city, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.city_.IsDefault()) {
    _impl_.city_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:patient_message.city)
}

// string street = 3;
inline void patient_message::clear_street() {
  _impl_.street_.ClearToEmpty();
}
inline const std::string& patient_message::street() const {
  // @@protoc_insertion_point(field_get:patient_message.street)
  return _internal_street();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void patient_message::set_street(ArgT0&& arg0, ArgT... args) {
 
 _impl_.street_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:patient_message.street)
}
inline std::string* patient_message::mutable_street() {
  std::string* _s = _internal_mutable_street();
  // @@protoc_insertion_point(field_mutable:patient_message.street)
  return _s;
}
inline const std::string& patient_message::_internal_street() const {
  return _impl_.street_.Get();
}
inline void patient_message::_internal_set_street(const std::string& value) {
  
  _impl_.street_.Set(value, GetArenaForAllocation());
}
inline std::string* patient_message::_internal_mutable_street() {
  
  return _impl_.street_.Mutable(GetArenaForAllocation());
}
inline std::string* patient_message::release_street() {
  // @@protoc_insertion_point(field_release:patient_message.street)
  return _impl_.street_.Release();
}
inline void patient_message::set_allocated_street(std::string* street) {
  if (street != nullptr) {
    
  } else {
    
  }
  _impl_.street_.SetAllocated(street, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.street_.IsDefault()) {
    _impl_.street_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:patient_message.street)
}

// string postcode = 4;
inline void patient_message::clear_postcode() {
  _impl_.postcode_.ClearToEmpty();
}
inline const std::string& patient_message::postcode() const {
  // @@protoc_insertion_point(field_get:patient_message.postcode)
  return _internal_postcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void patient_message::set_postcode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.postcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:patient_message.postcode)
}
inline std::string* patient_message::mutable_postcode() {
  std::string* _s = _internal_mutable_postcode();
  // @@protoc_insertion_point(field_mutable:patient_message.postcode)
  return _s;
}
inline const std::string& patient_message::_internal_postcode() const {
  return _impl_.postcode_.Get();
}
inline void patient_message::_internal_set_postcode(const std::string& value) {
  
  _impl_.postcode_.Set(value, GetArenaForAllocation());
}
inline std::string* patient_message::_internal_mutable_postcode() {
  
  return _impl_.postcode_.Mutable(GetArenaForAllocation());
}
inline std::string* patient_message::release_postcode() {
  // @@protoc_insertion_point(field_release:patient_message.postcode)
  return _impl_.postcode_.Release();
}
inline void patient_message::set_allocated_postcode(std::string* postcode) {
  if (postcode != nullptr) {
    
  } else {
    
  }
  _impl_.postcode_.SetAllocated(postcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.postcode_.IsDefault()) {
    _impl_.postcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:patient_message.postcode)
}

// string birthdate = 5;
inline void patient_message::clear_birthdate() {
  _impl_.birthdate_.ClearToEmpty();
}
inline const std::string& patient_message::birthdate() const {
  // @@protoc_insertion_point(field_get:patient_message.birthdate)
  return _internal_birthdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void patient_message::set_birthdate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.birthdate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:patient_message.birthdate)
}
inline std::string* patient_message::mutable_birthdate() {
  std::string* _s = _internal_mutable_birthdate();
  // @@protoc_insertion_point(field_mutable:patient_message.birthdate)
  return _s;
}
inline const std::string& patient_message::_internal_birthdate() const {
  return _impl_.birthdate_.Get();
}
inline void patient_message::_internal_set_birthdate(const std::string& value) {
  
  _impl_.birthdate_.Set(value, GetArenaForAllocation());
}
inline std::string* patient_message::_internal_mutable_birthdate() {
  
  return _impl_.birthdate_.Mutable(GetArenaForAllocation());
}
inline std::string* patient_message::release_birthdate() {
  // @@protoc_insertion_point(field_release:patient_message.birthdate)
  return _impl_.birthdate_.Release();
}
inline void patient_message::set_allocated_birthdate(std::string* birthdate) {
  if (birthdate != nullptr) {
    
  } else {
    
  }
  _impl_.birthdate_.SetAllocated(birthdate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.birthdate_.IsDefault()) {
    _impl_.birthdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:patient_message.birthdate)
}

// .account_message username = 6;
inline bool patient_message::_internal_has_username() const {
  return this != internal_default_instance() && _impl_.username_ != nullptr;
}
inline bool patient_message::has_username() const {
  return _internal_has_username();
}
inline void patient_message::clear_username() {
  if (GetArenaForAllocation() == nullptr && _impl_.username_ != nullptr) {
    delete _impl_.username_;
  }
  _impl_.username_ = nullptr;
}
inline const ::account_message& patient_message::_internal_username() const {
  const ::account_message* p = _impl_.username_;
  return p != nullptr ? *p : reinterpret_cast<const ::account_message&>(
      ::_account_message_default_instance_);
}
inline const ::account_message& patient_message::username() const {
  // @@protoc_insertion_point(field_get:patient_message.username)
  return _internal_username();
}
inline void patient_message::unsafe_arena_set_allocated_username(
    ::account_message* username) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.username_);
  }
  _impl_.username_ = username;
  if (username) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:patient_message.username)
}
inline ::account_message* patient_message::release_username() {
  
  ::account_message* temp = _impl_.username_;
  _impl_.username_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::account_message* patient_message::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_release:patient_message.username)
  
  ::account_message* temp = _impl_.username_;
  _impl_.username_ = nullptr;
  return temp;
}
inline ::account_message* patient_message::_internal_mutable_username() {
  
  if (_impl_.username_ == nullptr) {
    auto* p = CreateMaybeMessage<::account_message>(GetArenaForAllocation());
    _impl_.username_ = p;
  }
  return _impl_.username_;
}
inline ::account_message* patient_message::mutable_username() {
  ::account_message* _msg = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:patient_message.username)
  return _msg;
}
inline void patient_message::set_allocated_username(::account_message* username) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.username_;
  }
  if (username) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(username);
    if (message_arena != submessage_arena) {
      username = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, username, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.username_ = username;
  // @@protoc_insertion_point(field_set_allocated:patient_message.username)
}

// -------------------------------------------------------------------

// prescribtion_message

// .med_event_message event = 1;
inline bool prescribtion_message::_internal_has_event() const {
  return this != internal_default_instance() && _impl_.event_ != nullptr;
}
inline bool prescribtion_message::has_event() const {
  return _internal_has_event();
}
inline void prescribtion_message::clear_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.event_ != nullptr) {
    delete _impl_.event_;
  }
  _impl_.event_ = nullptr;
}
inline const ::med_event_message& prescribtion_message::_internal_event() const {
  const ::med_event_message* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::med_event_message&>(
      ::_med_event_message_default_instance_);
}
inline const ::med_event_message& prescribtion_message::event() const {
  // @@protoc_insertion_point(field_get:prescribtion_message.event)
  return _internal_event();
}
inline void prescribtion_message::unsafe_arena_set_allocated_event(
    ::med_event_message* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescribtion_message.event)
}
inline ::med_event_message* prescribtion_message::release_event() {
  
  ::med_event_message* temp = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::med_event_message* prescribtion_message::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:prescribtion_message.event)
  
  ::med_event_message* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::med_event_message* prescribtion_message::_internal_mutable_event() {
  
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::med_event_message>(GetArenaForAllocation());
    _impl_.event_ = p;
  }
  return _impl_.event_;
}
inline ::med_event_message* prescribtion_message::mutable_event() {
  ::med_event_message* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:prescribtion_message.event)
  return _msg;
}
inline void prescribtion_message::set_allocated_event(::med_event_message* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_ = event;
  // @@protoc_insertion_point(field_set_allocated:prescribtion_message.event)
}

// string medicine = 2;
inline void prescribtion_message::clear_medicine() {
  _impl_.medicine_.ClearToEmpty();
}
inline const std::string& prescribtion_message::medicine() const {
  // @@protoc_insertion_point(field_get:prescribtion_message.medicine)
  return _internal_medicine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void prescribtion_message::set_medicine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.medicine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prescribtion_message.medicine)
}
inline std::string* prescribtion_message::mutable_medicine() {
  std::string* _s = _internal_mutable_medicine();
  // @@protoc_insertion_point(field_mutable:prescribtion_message.medicine)
  return _s;
}
inline const std::string& prescribtion_message::_internal_medicine() const {
  return _impl_.medicine_.Get();
}
inline void prescribtion_message::_internal_set_medicine(const std::string& value) {
  
  _impl_.medicine_.Set(value, GetArenaForAllocation());
}
inline std::string* prescribtion_message::_internal_mutable_medicine() {
  
  return _impl_.medicine_.Mutable(GetArenaForAllocation());
}
inline std::string* prescribtion_message::release_medicine() {
  // @@protoc_insertion_point(field_release:prescribtion_message.medicine)
  return _impl_.medicine_.Release();
}
inline void prescribtion_message::set_allocated_medicine(std::string* medicine) {
  if (medicine != nullptr) {
    
  } else {
    
  }
  _impl_.medicine_.SetAllocated(medicine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.medicine_.IsDefault()) {
    _impl_.medicine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prescribtion_message.medicine)
}

// string dose = 3;
inline void prescribtion_message::clear_dose() {
  _impl_.dose_.ClearToEmpty();
}
inline const std::string& prescribtion_message::dose() const {
  // @@protoc_insertion_point(field_get:prescribtion_message.dose)
  return _internal_dose();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void prescribtion_message::set_dose(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dose_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prescribtion_message.dose)
}
inline std::string* prescribtion_message::mutable_dose() {
  std::string* _s = _internal_mutable_dose();
  // @@protoc_insertion_point(field_mutable:prescribtion_message.dose)
  return _s;
}
inline const std::string& prescribtion_message::_internal_dose() const {
  return _impl_.dose_.Get();
}
inline void prescribtion_message::_internal_set_dose(const std::string& value) {
  
  _impl_.dose_.Set(value, GetArenaForAllocation());
}
inline std::string* prescribtion_message::_internal_mutable_dose() {
  
  return _impl_.dose_.Mutable(GetArenaForAllocation());
}
inline std::string* prescribtion_message::release_dose() {
  // @@protoc_insertion_point(field_release:prescribtion_message.dose)
  return _impl_.dose_.Release();
}
inline void prescribtion_message::set_allocated_dose(std::string* dose) {
  if (dose != nullptr) {
    
  } else {
    
  }
  _impl_.dose_.SetAllocated(dose, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dose_.IsDefault()) {
    _impl_.dose_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prescribtion_message.dose)
}

// string exp_date = 4;
inline void prescribtion_message::clear_exp_date() {
  _impl_.exp_date_.ClearToEmpty();
}
inline const std::string& prescribtion_message::exp_date() const {
  // @@protoc_insertion_point(field_get:prescribtion_message.exp_date)
  return _internal_exp_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void prescribtion_message::set_exp_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exp_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prescribtion_message.exp_date)
}
inline std::string* prescribtion_message::mutable_exp_date() {
  std::string* _s = _internal_mutable_exp_date();
  // @@protoc_insertion_point(field_mutable:prescribtion_message.exp_date)
  return _s;
}
inline const std::string& prescribtion_message::_internal_exp_date() const {
  return _impl_.exp_date_.Get();
}
inline void prescribtion_message::_internal_set_exp_date(const std::string& value) {
  
  _impl_.exp_date_.Set(value, GetArenaForAllocation());
}
inline std::string* prescribtion_message::_internal_mutable_exp_date() {
  
  return _impl_.exp_date_.Mutable(GetArenaForAllocation());
}
inline std::string* prescribtion_message::release_exp_date() {
  // @@protoc_insertion_point(field_release:prescribtion_message.exp_date)
  return _impl_.exp_date_.Release();
}
inline void prescribtion_message::set_allocated_exp_date(std::string* exp_date) {
  if (exp_date != nullptr) {
    
  } else {
    
  }
  _impl_.exp_date_.SetAllocated(exp_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exp_date_.IsDefault()) {
    _impl_.exp_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prescribtion_message.exp_date)
}

// -------------------------------------------------------------------

// procedure_message

// .med_event_message event = 1;
inline bool procedure_message::_internal_has_event() const {
  return this != internal_default_instance() && _impl_.event_ != nullptr;
}
inline bool procedure_message::has_event() const {
  return _internal_has_event();
}
inline void procedure_message::clear_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.event_ != nullptr) {
    delete _impl_.event_;
  }
  _impl_.event_ = nullptr;
}
inline const ::med_event_message& procedure_message::_internal_event() const {
  const ::med_event_message* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::med_event_message&>(
      ::_med_event_message_default_instance_);
}
inline const ::med_event_message& procedure_message::event() const {
  // @@protoc_insertion_point(field_get:procedure_message.event)
  return _internal_event();
}
inline void procedure_message::unsafe_arena_set_allocated_event(
    ::med_event_message* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:procedure_message.event)
}
inline ::med_event_message* procedure_message::release_event() {
  
  ::med_event_message* temp = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::med_event_message* procedure_message::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:procedure_message.event)
  
  ::med_event_message* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::med_event_message* procedure_message::_internal_mutable_event() {
  
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::med_event_message>(GetArenaForAllocation());
    _impl_.event_ = p;
  }
  return _impl_.event_;
}
inline ::med_event_message* procedure_message::mutable_event() {
  ::med_event_message* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:procedure_message.event)
  return _msg;
}
inline void procedure_message::set_allocated_event(::med_event_message* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_ = event;
  // @@protoc_insertion_point(field_set_allocated:procedure_message.event)
}

// .account_message who_performs = 2;
inline bool procedure_message::_internal_has_who_performs() const {
  return this != internal_default_instance() && _impl_.who_performs_ != nullptr;
}
inline bool procedure_message::has_who_performs() const {
  return _internal_has_who_performs();
}
inline void procedure_message::clear_who_performs() {
  if (GetArenaForAllocation() == nullptr && _impl_.who_performs_ != nullptr) {
    delete _impl_.who_performs_;
  }
  _impl_.who_performs_ = nullptr;
}
inline const ::account_message& procedure_message::_internal_who_performs() const {
  const ::account_message* p = _impl_.who_performs_;
  return p != nullptr ? *p : reinterpret_cast<const ::account_message&>(
      ::_account_message_default_instance_);
}
inline const ::account_message& procedure_message::who_performs() const {
  // @@protoc_insertion_point(field_get:procedure_message.who_performs)
  return _internal_who_performs();
}
inline void procedure_message::unsafe_arena_set_allocated_who_performs(
    ::account_message* who_performs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.who_performs_);
  }
  _impl_.who_performs_ = who_performs;
  if (who_performs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:procedure_message.who_performs)
}
inline ::account_message* procedure_message::release_who_performs() {
  
  ::account_message* temp = _impl_.who_performs_;
  _impl_.who_performs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::account_message* procedure_message::unsafe_arena_release_who_performs() {
  // @@protoc_insertion_point(field_release:procedure_message.who_performs)
  
  ::account_message* temp = _impl_.who_performs_;
  _impl_.who_performs_ = nullptr;
  return temp;
}
inline ::account_message* procedure_message::_internal_mutable_who_performs() {
  
  if (_impl_.who_performs_ == nullptr) {
    auto* p = CreateMaybeMessage<::account_message>(GetArenaForAllocation());
    _impl_.who_performs_ = p;
  }
  return _impl_.who_performs_;
}
inline ::account_message* procedure_message::mutable_who_performs() {
  ::account_message* _msg = _internal_mutable_who_performs();
  // @@protoc_insertion_point(field_mutable:procedure_message.who_performs)
  return _msg;
}
inline void procedure_message::set_allocated_who_performs(::account_message* who_performs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.who_performs_;
  }
  if (who_performs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(who_performs);
    if (message_arena != submessage_arena) {
      who_performs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, who_performs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.who_performs_ = who_performs;
  // @@protoc_insertion_point(field_set_allocated:procedure_message.who_performs)
}

// string when = 3;
inline void procedure_message::clear_when() {
  _impl_.when_.ClearToEmpty();
}
inline const std::string& procedure_message::when() const {
  // @@protoc_insertion_point(field_get:procedure_message.when)
  return _internal_when();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void procedure_message::set_when(ArgT0&& arg0, ArgT... args) {
 
 _impl_.when_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:procedure_message.when)
}
inline std::string* procedure_message::mutable_when() {
  std::string* _s = _internal_mutable_when();
  // @@protoc_insertion_point(field_mutable:procedure_message.when)
  return _s;
}
inline const std::string& procedure_message::_internal_when() const {
  return _impl_.when_.Get();
}
inline void procedure_message::_internal_set_when(const std::string& value) {
  
  _impl_.when_.Set(value, GetArenaForAllocation());
}
inline std::string* procedure_message::_internal_mutable_when() {
  
  return _impl_.when_.Mutable(GetArenaForAllocation());
}
inline std::string* procedure_message::release_when() {
  // @@protoc_insertion_point(field_release:procedure_message.when)
  return _impl_.when_.Release();
}
inline void procedure_message::set_allocated_when(std::string* when) {
  if (when != nullptr) {
    
  } else {
    
  }
  _impl_.when_.SetAllocated(when, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.when_.IsDefault()) {
    _impl_.when_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:procedure_message.when)
}

// string room = 4;
inline void procedure_message::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& procedure_message::room() const {
  // @@protoc_insertion_point(field_get:procedure_message.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void procedure_message::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:procedure_message.room)
}
inline std::string* procedure_message::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:procedure_message.room)
  return _s;
}
inline const std::string& procedure_message::_internal_room() const {
  return _impl_.room_.Get();
}
inline void procedure_message::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* procedure_message::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* procedure_message::release_room() {
  // @@protoc_insertion_point(field_release:procedure_message.room)
  return _impl_.room_.Release();
}
inline void procedure_message::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:procedure_message.room)
}

// -------------------------------------------------------------------

// schedule_message

// .account_message who = 1;
inline bool schedule_message::_internal_has_who() const {
  return this != internal_default_instance() && _impl_.who_ != nullptr;
}
inline bool schedule_message::has_who() const {
  return _internal_has_who();
}
inline void schedule_message::clear_who() {
  if (GetArenaForAllocation() == nullptr && _impl_.who_ != nullptr) {
    delete _impl_.who_;
  }
  _impl_.who_ = nullptr;
}
inline const ::account_message& schedule_message::_internal_who() const {
  const ::account_message* p = _impl_.who_;
  return p != nullptr ? *p : reinterpret_cast<const ::account_message&>(
      ::_account_message_default_instance_);
}
inline const ::account_message& schedule_message::who() const {
  // @@protoc_insertion_point(field_get:schedule_message.who)
  return _internal_who();
}
inline void schedule_message::unsafe_arena_set_allocated_who(
    ::account_message* who) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.who_);
  }
  _impl_.who_ = who;
  if (who) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:schedule_message.who)
}
inline ::account_message* schedule_message::release_who() {
  
  ::account_message* temp = _impl_.who_;
  _impl_.who_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::account_message* schedule_message::unsafe_arena_release_who() {
  // @@protoc_insertion_point(field_release:schedule_message.who)
  
  ::account_message* temp = _impl_.who_;
  _impl_.who_ = nullptr;
  return temp;
}
inline ::account_message* schedule_message::_internal_mutable_who() {
  
  if (_impl_.who_ == nullptr) {
    auto* p = CreateMaybeMessage<::account_message>(GetArenaForAllocation());
    _impl_.who_ = p;
  }
  return _impl_.who_;
}
inline ::account_message* schedule_message::mutable_who() {
  ::account_message* _msg = _internal_mutable_who();
  // @@protoc_insertion_point(field_mutable:schedule_message.who)
  return _msg;
}
inline void schedule_message::set_allocated_who(::account_message* who) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.who_;
  }
  if (who) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(who);
    if (message_arena != submessage_arena) {
      who = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, who, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.who_ = who;
  // @@protoc_insertion_point(field_set_allocated:schedule_message.who)
}

// uint64 id = 2;
inline void schedule_message::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t schedule_message::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t schedule_message::id() const {
  // @@protoc_insertion_point(field_get:schedule_message.id)
  return _internal_id();
}
inline void schedule_message::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void schedule_message::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:schedule_message.id)
}

// string start = 3;
inline void schedule_message::clear_start() {
  _impl_.start_.ClearToEmpty();
}
inline const std::string& schedule_message::start() const {
  // @@protoc_insertion_point(field_get:schedule_message.start)
  return _internal_start();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void schedule_message::set_start(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule_message.start)
}
inline std::string* schedule_message::mutable_start() {
  std::string* _s = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:schedule_message.start)
  return _s;
}
inline const std::string& schedule_message::_internal_start() const {
  return _impl_.start_.Get();
}
inline void schedule_message::_internal_set_start(const std::string& value) {
  
  _impl_.start_.Set(value, GetArenaForAllocation());
}
inline std::string* schedule_message::_internal_mutable_start() {
  
  return _impl_.start_.Mutable(GetArenaForAllocation());
}
inline std::string* schedule_message::release_start() {
  // @@protoc_insertion_point(field_release:schedule_message.start)
  return _impl_.start_.Release();
}
inline void schedule_message::set_allocated_start(std::string* start) {
  if (start != nullptr) {
    
  } else {
    
  }
  _impl_.start_.SetAllocated(start, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_.IsDefault()) {
    _impl_.start_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule_message.start)
}

// string end = 4;
inline void schedule_message::clear_end() {
  _impl_.end_.ClearToEmpty();
}
inline const std::string& schedule_message::end() const {
  // @@protoc_insertion_point(field_get:schedule_message.end)
  return _internal_end();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void schedule_message::set_end(ArgT0&& arg0, ArgT... args) {
 
 _impl_.end_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule_message.end)
}
inline std::string* schedule_message::mutable_end() {
  std::string* _s = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:schedule_message.end)
  return _s;
}
inline const std::string& schedule_message::_internal_end() const {
  return _impl_.end_.Get();
}
inline void schedule_message::_internal_set_end(const std::string& value) {
  
  _impl_.end_.Set(value, GetArenaForAllocation());
}
inline std::string* schedule_message::_internal_mutable_end() {
  
  return _impl_.end_.Mutable(GetArenaForAllocation());
}
inline std::string* schedule_message::release_end() {
  // @@protoc_insertion_point(field_release:schedule_message.end)
  return _impl_.end_.Release();
}
inline void schedule_message::set_allocated_end(std::string* end) {
  if (end != nullptr) {
    
  } else {
    
  }
  _impl_.end_.SetAllocated(end, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_.IsDefault()) {
    _impl_.end_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule_message.end)
}

// string type = 5;
inline void schedule_message::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& schedule_message::type() const {
  // @@protoc_insertion_point(field_get:schedule_message.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void schedule_message::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule_message.type)
}
inline std::string* schedule_message::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:schedule_message.type)
  return _s;
}
inline const std::string& schedule_message::_internal_type() const {
  return _impl_.type_.Get();
}
inline void schedule_message::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* schedule_message::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* schedule_message::release_type() {
  // @@protoc_insertion_point(field_release:schedule_message.type)
  return _impl_.type_.Release();
}
inline void schedule_message::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule_message.type)
}

// string room = 6;
inline void schedule_message::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& schedule_message::room() const {
  // @@protoc_insertion_point(field_get:schedule_message.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void schedule_message::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule_message.room)
}
inline std::string* schedule_message::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:schedule_message.room)
  return _s;
}
inline const std::string& schedule_message::_internal_room() const {
  return _impl_.room_.Get();
}
inline void schedule_message::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* schedule_message::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* schedule_message::release_room() {
  // @@protoc_insertion_point(field_release:schedule_message.room)
  return _impl_.room_.Release();
}
inline void schedule_message::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule_message.room)
}

// repeated .med_event_message events = 7;
inline int schedule_message::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int schedule_message::events_size() const {
  return _internal_events_size();
}
inline void schedule_message::clear_events() {
  _impl_.events_.Clear();
}
inline ::med_event_message* schedule_message::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:schedule_message.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::med_event_message >*
schedule_message::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:schedule_message.events)
  return &_impl_.events_;
}
inline const ::med_event_message& schedule_message::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::med_event_message& schedule_message::events(int index) const {
  // @@protoc_insertion_point(field_get:schedule_message.events)
  return _internal_events(index);
}
inline ::med_event_message* schedule_message::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::med_event_message* schedule_message::add_events() {
  ::med_event_message* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:schedule_message.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::med_event_message >&
schedule_message::events() const {
  // @@protoc_insertion_point(field_list:schedule_message.events)
  return _impl_.events_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_com_2eproto
